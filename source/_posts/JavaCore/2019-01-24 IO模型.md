---
layout: post
title: IO模型
tags:
- JavaCore
categories: JavaCore
description: JavaCore
---

本文先从同步和异步的概念 说起，然后接着阐述了阻塞和非阻塞的区别，接着介绍了阻塞IO和非阻塞IO的区别，然后介绍了同步IO和异步IO的区别，接下来介绍了5种IO模型， 最后讲述Java NIO 中的 

<!-- more --> 

### 1 同步？异步？ 

​	同步和异步的概念出来已经很久了，网上有关同步和异步的说法也有很多。以下是我个人的理解：

　　**同步**：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；

　　**异步**：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

　　这就是同步和异步。举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。

　　事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，**一个事件的发生或执行是否会导致整个流程的暂时等待**。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。

　　因此，个人觉得同步和异步可以表现在很多方面，但是记住其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。

### 2 阻塞？ 非阻塞？

	在前面介绍了同步和异步的区别，这一节来看一下阻塞和非阻塞的区别。

　　**阻塞**：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；

　　**非阻塞**：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。

　　这就是阻塞和非阻塞的区别。也就是说**阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息**。

　　举个简单的例子：

　　假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。

　　在网上有一些朋友将同步和异步分别与阻塞和非阻塞画上等号，事实上，它们是两组完全不同的概念。注意，理解这两组概念的区别对于后面IO模型的理解非常重要。

　　同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；

　　而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。

　　理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。

### 3 阻塞IO？ 非阻塞IO？

​	在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。

　　通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。

　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：

　　1）**查看数据是否就绪**；

　　2）**进行数据拷贝（内核将数据拷贝到用户线程）**。

　　**那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息**。

　　Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。

### 4 同步IO？ 异步IO？

　　从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；

　　而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。

　　事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：

　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；

　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。

　　这是同步IO和异步IO关键区别所在，**同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成**。所以说异步IO必须要有操作系统的底层支持。

　　注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。

　　阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。

### 5 五种IO模型介绍

#### 5.1 同步阻塞

在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：

第一步通常涉及等待数据从网络中到达。当所有等待数据到达时，它被复制到内核中的某个缓冲区。

第二步就是把数据从内核缓冲区复制到应用程序缓冲区。

![IO1](/images/JavaCore/javaCore_IO01.png)

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除 block的状态，重新运行起来。

**所以，blocking IO的特点就是在IO执行的两个阶段都被block了。**

#### 5.2 非阻塞IO模型 

linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：

![IO2](/images/JavaCore/javaCore_IO02.png)

从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

**所以，用户进程第一个阶段不是阻塞的,需要不断的主动询问kernel数据好了没有；第二个阶段依然总是阻塞的。**

#### 5.3 多路复用IO模型 

IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。

IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。

它的基本原理就是select /epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：

![IO3](/images/JavaCore/javaCore_IO03.png)

当用户进程调用了`select`，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个 socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用 select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。

select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。

在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被 block的。只不过process是被select这个函数block，而不是被socket IO给block。

#### 5.4 信号驱动IO模型 

![IO4](/images/JavaCore/javaCore_IO04.png)

#### 5.5 异步IO模型 

这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。如图：

![IO5](/images/JavaCore/javaCore_IO05.png)

### 6 Java NIO

##### 1 io与nio区别

| IO模型 | IO           | NIO          |
| ------ | ------------ | ------------ |
| 方式   | 从硬盘到内存 | 从内存到硬盘 |
| 通信   | 面向流       | 面向缓冲     |
| 处理   | 阻塞IO       | 非阻塞IO     |
| 触发   | 无           | 选择器       |

Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

##### 2 Java NIO概念

1. **Channels和Buffers**: 在标准IO接口中我们最常用的是字节流（byte strams）和字符流（character streams）。在NIO接口中我们需要使用Channel和Buffer进行IO操作，Channel模拟了流的概念，但是又有不同。数据总是从一个Channel读到一个buffer中，或者从一个buffer中写到channel中。
2. **Non-blocking IO**： Java NIO接口的核心就是提供了非阻塞IO的能力（Non-blocking IO）。例如：一个线程可以请求channel读取数据到buffer中，在channel读取数据的过程中，线程可以处理其他的事情，一旦数据已经读取到buffer中，线程可以继续处理buffer中的数据；对于将buffer中的数据写到channel中道理是一样的。
3. **Selectors**：Java NIO包含了Selectors的设计，Selector通过事件驱动多个Channel的对象，Selector可以实现让一个线程管理使用多个数据的Channel。

Channel和Buffer通常是共同使用的，一般来讲，所有的IO和NIO操作都从一个channel开始，channel有点像stream，数据可以通过channel读取到buffer里；也可以将数据从buffer写到channel中Java NIO提供了很多种channel和buffer类型；Channel接口主要实现类如下：

```shell
FileChannel
DatagramChannel
SocketChannel
ServerSocketChannel
```

##### 3 Channel

JavaNIO Channels和流有一些相似，但是又有些不同：

- 你可以同时读和写Channels，流Stream只支持单向的读或写（InputStream/OutputStream）
- Channels可以异步的读和写，流Stream是同步的
- Channels总是读取到buffer或者从buffer中写入

```shell
Channel最重要的一些实现类：
FileChannel : 可以读写文件中的数据
DatagramChannel：可以通过UDP协议读写数据
SocketChannel：可以通过TCP协议读写数据
ServerSocketChannel：允许我们像一个web服务器那样监听TCP链接请求，为每一个链接请求创建SocketChannel
```

下面是一个基本的使用FileChannel读取数据到buffer的例子：

```shell
public class FileChannelExam {
    public static void main(String[] args){
        try {
            String path = FileChannelExam.class.getResource("/data/nio-data.txt").getPath();
            // 创建一个文件通道
            RandomAccessFile file = new RandomAccessFile(path, "rw");
            FileChannel channel = file.getChannel();
            // 创建一个字节buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            // 读取数据到buffer
            int len = channel.read(buffer);
            while (len != -1){
                System.out.println("Read " + len);
                // 将写模式转变为读模式，
                // 将写模式下的buffer内容最后位置设为读模式下的limit位置，作为读越界位，同时将读位置设为0
                // 表示转换后重头开始读，同时消除写模式的mark标记
                buffer.flip();
                // 判断当前读取位置是否到达越界位（position < limit）
                while (buffer.hasRemaining()){
                     // 读取当前position的字节（position++）
                    System.out.println(buffer.get());
                }
                // 清空当前buffer内容
                buffer.clear();
                len = channel.read(buffer);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

需要注意buffer.flip()方法，首先我们从Channel读取数据写入到Buffer，然后调用flip将切换到读模式，才能从buffer中读取数据。

##### 4 Buffer

在Java NIO中各类Buffer主要用于和NIO Channel进行交互，数据从Channel中读取到Buffer中，从Buffer写入到Channel中。

![IO6](/images/JavaCore/javaCore_IO06.png)

我们可以将Buffer看做内存中的一块区域，我们可以在这块区域上写数据，然后在从中读取。这块内存区域被包装成NIO Buffer对象，提供了一系列的方法使我们操作这块内存变得更简单一些。

使用Buffer进行读写数据一般会通过下边四个步骤处理：

1. 将数据写到Buffer中
2. 调用buffer.flip()切换为读模式
3. 从Buffer中读取数据
4. 调用buffer.clear()或者buffer.compact()清空或压缩buffer

下边是个简单的Buffer使用的例子

```shell
public class FileChannelExam {
    public static void main(String[] args){
        try {
            String path = FileChannelExam.class.getResource("/data/nio-data.txt").getPath();
            // 创建一个文件通道
            RandomAccessFile file = new RandomAccessFile(path, "rw");
            FileChannel channel = file.getChannel();
            // 创建一个字节buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            // 读取数据到buffer
            int len = channel.read(buffer);
            while (len != -1){
                System.out.println("Read " + len);
                // 将写模式转变为读模式，
                // 将写模式下的buffer内容最后位置设为读模式下的limit位置，作为读越界位，同时将读位置设为0
                // 表示转换后重头开始读，同时消除写模式的mark标记
                buffer.flip();
                // 判断当前读取位置是否到达越界位（position < limit）
                while (buffer.hasRemaining()){
                     // 读取当前position的字节（position++）
                    System.out.println(buffer.get());
                }
                // 清空当前buffer内容
                buffer.clear();
                len = channel.read(buffer);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

当我们将数据写入buffer时，buffer会记录我们写入了多少数据，当需要读取数据的时候，需要调用flip()方法将buffer从写模式切换到读模式，在读模式下，buffer允许用户读取已经写入buffer的所有数据。

一旦我们已经读取了buffer中的所有数据，我们需要清空buffer以便写一次写入数据。我们可以使用两种方法达到这个目的：

- 调用clear()方法：清空整个buffer；
- 调用compact()方法：仅清空已经读取的数据，未读取的数据移动到buffer的起始位置，新写入的数据会放到未读取数据的后边。

**Buffer的 capacity, position 和limit**

Buffer对象使用capacity，position，limit三个属性来保存内存状态以便灵活操作内存，了解这三个属性的作用是理解Buffer工作原理的关键。position和limit决定了Buffer可以读写的区域（position <= x < limit），capacity 表示读写的最大容量

下图模拟了Buffer在读、写模式下capacity、position、limit的状态。

![IO7](/images/JavaCore/javaCore_IO07.png)

**capacity**: 

作为一块内存，buffer必须有一个固定容量，这就是buffer的capacity。你最多只能写入capacity容量的数据到buffer中，一旦buffer中被写满数据，在你写入新的数据之前需要置空buffer（通过读取数据或直接清空）。

**position**: 

当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.

当读取数据时，也是从某个特定位置读。  当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。

**limit** :

在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。

当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）

代码展示

```shell
## 1.申请一个Buffer
// 创建一个1024字节的ByteBuffer对象
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

// 创建一个1024字符的CharBuffer对象
CharBuffer charBuffer = CharBuffer.allocate(1024);

## 2.写入数据到buffer中
// 通过Channel写入，即将Channel数据读取到buffer中
int len = channel.read(buffer);

// 直接写入，调用put方法
buffer.put(127);

## 3.flip()写切换到读
public final Buffer flip() {
    limit = position; 
    position = 0;
    mark = -1;
    return this;
}

## 4.从buffer中读取数据
// 使用Channel读取数据，即将数据写入Channel
int len = channel.write(buffer);

// 直接读取数据
byte data = buffer.get();

## 5.倒回rewind()
public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}

## 6.clear()和compact()
public final Buffer clear() {
    position = 0;
    limit = capacity; 
    mark = -1;
    return this;
}

## 7 Channel中的数据读取到多个Buffer
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);

ByteBuffer[] buffers = { header, body };

channel.read(buffers);

## 8 将多个buffer的数据写入到同一个Channel
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);

// 写入数据
ByteBuffer[] bufferArray = { header, body };
channel.write(bufferArray);
```

##### 5 Selector

Selector是Java NIO中用于管理一个或多个Channel的组件，控制决定对哪些Channel进行读写；通过使用Selector让一个单线程可以管理多个Channel甚至多个网络连接。

使用Selector最大的优势就是可以在较少的线程中控制更多的Channel。事实上我们可以使用一个线程控制需要使用的所有Channel。操作系统线程的运行和切换需要一定的开销，使用的线程越小，系统开销也就越少；因此使用Selector可以节省很多系统开销。下图展示了一个线程使用Selector控制三个Channel的情形。

![IO8](/images/JavaCore/javaCore_IO08.png)

**创建Selector**

```shell
Selector selector = Selector.open();
```

**注册Channel**

想要通过Selector中控制Channel，必须将Channel注册到Selector中，通过SelectableChannel.register()方法实现。

```shell
channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
```

需要注意的是注册到Selector的Channel必须是非阻塞模式的（non-blocking），FileChannel是无法使用的因为FileChannel无法切换到非阻塞模式，SocketChannel非常适合配合Selector使用。
register方法的第二个参数是监听设置，用于设置注册的channel通过Selector监听的操作事件类型，总共有四类事件可以监听：Connect. Accept. Read. Write

JavaNIO中在SelectionKey中有四个静态变量表示这四类事件：

1. SelectionKey.OP_CONNECT
2. SelectionKey.OP_ACCEPT
3. SelectionKey.OP_READ
4. SelectionKey.OP_WRITE

**SelectionKey对象**

Channel注册到Selector后会返回一个SelectionKey对象，这个对象包含了下面一些重要属性：

事件监听集合（interest set）:

监听集合（interest set）是channel在selector监听的事件类型的集合，可以同SelectionKey读写这个配置。

```shell
int interestSet = selectionKey.interestOps();

// 通过 & 操作判断监听配置是否包含某类事件
boolean isInterestedInAccept = interestSet & SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
boolean isInterestedInRead = interestSet & SelectionKey.OP_READ;
boolean isInterestedInWrite = interestSet & SelectionKey.OP_WRITE;
```

就绪集合（ready set）

就绪集合（ready set）是channel已经就绪的操作的集合，我们主要在一个selection操作后访问就绪集合。

```shell
int readySet = selectionKey.readyOps();
// 可以使用和interest set 同样的方法测试集合中是否包含某类事件，
// 也可以通过调用下边的一些方法进行判断：
selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
```

Channel对象

```shell
Channel channel = selectionKey.channel();
```

Selector对象

```
Selector selector = selectionKey.selector();
```

一个可选附属对象（an attached object (optional) ）

可以给SelectionKey添加一个附加对象，通常用来标记Channel或者Channel的特征信息。例如，我们可以将和Channel配合使用的Buffer附加到SelectionKey上。

```shell
//  附加对象
selectionKey.attach(theObject);
// 获取附加对象 
Object attachedObj = selectionKey.attachment();
// 还可以再注册channel的时候直接添加附加对象
SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
```

通过Selector选择Channel

将多个Channel注册到Selector后，我们就可以通过调用select()方法选择监听了特定事件（connect，accept，read，write）并且已经就绪的Channel。换种说法就是，如果你已经注册了一个监听read事件的channel，它就会通过select()方法接收到read事件。
select方法有几种不同的重载：

- int select()：阻塞直到至少有一个channel对监听的事件操作准备就绪
- int select(long timeout)：和select()方法一样，但只会阻塞到指定的超时时间；
- int selectNow()：不会阻塞，无论是否有就绪的channel都会立即返回。

三个方法的返回值是最后一次调用select()后就绪的channel的数量，如果你调用select()返回1，表示调用select()后有一个channel准备就绪了；当你再次调用sleect()时再返回1，表示这次又有一个channel就绪了，如果对第一次调用就绪的channel没有做任何操作，这时总共有两个已经准备就绪的channel，在两次调用中都只有一个channel变为就绪状态。

**完整流程（伪代码）**

```shell
Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

while(true) {

    int readyChannels = selector.select();

    if(readyChannels == 0) continue;


    Set<SelectionKey> selectedKeys = selector.selectedKeys();

    Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

    while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.
    } else if (key.isConnectable()) {
        // a connection was established with a remote server.
    } else if (key.isReadable()) {
        // a channel is ready for reading
    } else if (key.isWritable()) {
        // a channel is ready for writing
    }
    keyIterator.remove();
    }
}
```













