---
layout: post
title: 02 spring事物
tags:
- SpringCore
categories: SpringCore
description: spring源码
---

本篇介绍spring事物

<!-- more --> 

## spring事物源码

### 1.基本概念

#### 1.1基本名词概念

| 名词                              | 概念                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| PlatformTransactionManager        | 事务管理器，管理事务的各生命周期方法，下文简称TxMgr          |
| TransactionAttribute              | 事务属性, 包含隔离级别，传播行为,是否只读等信息，下文简称TxAttr |
| TransactionStatus                 | 事务状态，下文简称TxStatus                                   |
| TransactionInfo                   | 事务信息，内含TxMgr, TxAttr, TxStatus等信息，下文简称TxInfo  |
| TransactionSynchronization        | 事务同步回调，内含多个钩子方法，下文简称TxSync / transaction synchronization |
| TransactionSynchronizationManager | 事务同步管理器，维护当前线程事务资源，信息以及TxSync集合     |

 #### 1.2 七种事物传播行为

- REQUIRED
  如果当前无事务则开启一个事务，否则加入当前事务。
- SUPPORTS
  如果当前有事务则加入当前事务。
- MANDATORY
  如果当前无事务则抛出异常，否则加入当前事务。
- REQUIRES_NEW
  如果当前无事务则开启一个事务，否则挂起当前事务并开启新事务。
- NOT_SUPPORTED
  如果当前有事务，则挂起当前事务以无事务状态执行方法。
- NEVER
  如果当前有事务，则抛出异常。
- NESTED
  创建一个嵌套事务，如果当前无事务则创建一个事务。

#### 1.3 套路讲解

1. ProxyFactory 创建代理对象 -->
2.  JdkDynamicAopProxy#invoke  代理类执行 -- >
3. 代理会执行到： ReflectiveMethodInvocation#proceed 方法 -->
4. 最终会执行到：TransactionInterceptor#invoke 方法

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    MethodInvocation invocation;
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Class<?> targetClass = null;
    Object target = null;

    try {
        // 如果目标方法没有实现equals
        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        // 如果目标方法没有实现hashcode
        if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        // 根据代理对象的配置来调用服务
        if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&
                method.getDeclaringClass().isAssignableFrom(Advised.class)) {
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;

        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // May be null. Get as late as possible to minimize the time we "own" the target,
        // in case it comes from a pool.
        // 获取目标对象
        target = targetSource.getTarget();
        if (target != null) {
            targetClass = target.getClass();
        }

        // 获取定义好的拦截器链
        // Get the interception chain for this method.
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // Check whether we have any advice. If we don't, we can fallback on direct
        // reflective invocation of the target, and avoid creating a MethodInvocation.
        if (chain.isEmpty()) {
            // We can skip creating a MethodInvocation: just invoke the target directly
            // Note that the final invoker must be an InvokerInterceptor so we know it does
            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
            // 没有拦截链则直接调用target方法
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);
        }
        else {
            // We need to create a method invocation...
            //对拦截链进行封装  得到对象ReflectiveMethodInvocation 调用 proceed 方法
            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            retVal = invocation.proceed();// 方法内部将执行拦截器的切面直到目标方法被执行
        }

        // Massage return value if necessary.
        Class<?> returnType = method.getReturnType();
        if (retVal != null && retVal == target && returnType.isInstance(proxy) &&
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned "this" and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {
            throw new AopInvocationException(
                    "Null return value from advice does not match primitive return type for: " + method);
        }
        return retVal;
    }
    finally {
        if (target != null && !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
```

##### 1.3.1 事务拦截器

我们给一个bean的方法加上`@Transactional`注解后，Spring容器给我们的是一个代理的bean。当我们对事务方法调用时，会进入Spring的ReflectiveMethodInvocation#proceed方法。这是AOP的主要实现，在进入业务方法前会调用各种方法拦截器，我们需要关注的拦截器是*org.springframework.transaction.interceptor.TransactionInterceptor*。 TransactionInterceptor的职责类似于一个“环绕切面”，在业务方法调用前根据情况开启事务，在业务方法调用完回到拦截器后进行善后清理。 



事务切面在源码中具体的实现方法是TransactionAspectSupport#invokeWithinTransaction，相信平时大家debug的时候在调用栈中经常能看到此方法。事务切面关注的是TransactionInfo(TxInfo)，TxInfo是一个“非常大局观”的东西（里面啥都有：TxMgr, TxAttr, TxStatus还有前一次进入事务切面的TransactionInfo)。 



因此事务切面会调用createTransactionIfNecessary方法来创建事务并拿到一个TxInfo（无论是否真的物理创建了一个事务）。如果事务块内的代码发生了异常，则会根据TxInfo里面的TxAttr配置的rollback规则看看这个异常是不是需要回滚，不需要回滚就尝试提交，否则就尝试回滚。如果未发生异常，则尝试提交。 

##### 1.3.2 提交与回滚

事务切面对于尝试提交会判断是否到了最外层事务(某个事务边界)。举个例子：有四个事务方法依次调用，传播行为分别是 方法1：REQUIRED, 方法2：REQUIRED, 方法3： REQUIRES_NEW, 方法4： REQUIRED。很显然这其中包含了两个独立的物理事务，当退栈到方法4的事务切面时，会发现没有到事务最外层，所以**不会有真正的物理提交**。而在退栈到了方法3对应的事务切面时会发现是外层事务，此时会发生物理提交。同理，退栈到方法1的事务切面时也会触发物理提交。 

那么问题来了，Spring是怎么判断这所谓“最外层事务”的呢。
答案是TxStatus中有个属性叫newTransaction用于标记是否是新建事务(根据事务传播行为得出，比如加入已有事务则会是false)，以及一个名为transaction的Object用于表示物理事务对象(由具体TxMgr子类负责给出）。Spring会根据每一层事务切面创建的TxStatus内部是否持有transaction对象以及newTransaction标志位判断是否属于外层事务。

类似的，Spring对于回滚事务也是会在最外层事务方法对应的切面中进行物理回滚。而在非最外层事务的时候会由具体txMgr子类给对应的事务打个的标记用于标识这个事务该回滚，这样的话在所有同一物理事务方法退栈过程中在事务切面中都能读取到事务被打了应该回滚的标记。可以说这是同一物理事务方法之间进行通信的机制。

##### 1.3.3 ThreadLocal的使用

Spring事务代码中用ThreadLocal来进行资源与事务的生命周期的同步管理。

在事务切面层面，TransactionAspectSupport里面有个transactionInfoHolder的ThreadLocal对象，用于把TxInfo绑定到线程。那么这样在我们的业务代码或者其他切面中，我们可以拿到TxInfo，也能拿到TxStatus。拿到TxStatus我们就可以调用setRollbackOnly来打标以手动控制事务必须回滚。

TransactionSynchronizationManager是Spring事务代码中对ThreadLocal使用最多的类，目前它内部含有6个ThreadLocal，分别是：

- resources
  类型为`Map<Object, Object>`用于保存事务相关资源，比如我们常用的DataSourceTransactionManager会在开启物理事务的时候把`<DataSource, ConnectionHolder>`绑定到线程。
  这样在事务作用的业务代码中可以通过Spring的DataSourceUtils拿到绑定到线程的ConnectionHolder中的Connection。事实上对于MyBatis来说与Spring集成时就是这样拿的。
- synchronizations
  类型为`Set<TransactionSynchronization>`用于保存transaction synchronization，这个可以理解为是回调钩子对象,内部含有beforeCommit, afterCommit, beforeCompletion等钩子方法。
  我们自己如果需要的话也可以在业务方法或者切面中注册一些transaction synchronization对象用于追踪事务生命周期做一些自定义的事情。
- currentTransactionName
  当前事务名
- currentTransactionReadOnly
  当前事务是否只读
- currentTransactionIsolationLevel
  当前事务隔离级别
- actualTransactionActive
  是否存在物理事务，比如传播行为为NOT_SUPPORTED时就会是false。

### 2.源码实现

#### 2.1 事物的入口--TransactionInterceptor

TransactionInterceptor是Spring实现声明式事务的拦截器，它实现了AOP联盟的MethodInterceptor接口，它的父类TransactionAspectSupport封装了一些用于实现事务切面对事务进行管理的基本代码。下面来看一下TransactionInterceptor的继承关系。 

![transactionInterceptor](/images/Spring/Spring_transactionInterceptor.png)

##### 2.1.1 TransactionInterceptor#invoke

TransactionInterceptor对于MethodInterceptor#invoke的实现很简单，就是调用父类的的invokeWithinTransaction，并传递给此方法一个回调用于继续后续的拦截调用。 

```java
@Override
public Object invoke(final MethodInvocation invocation) throws Throwable {
    // 因为这里的invocation.getThis可能是一个代理类，需要获取目标原生class。
    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

    // 调用父类TransactionAspectSupport的invokeWithinTransaction方法,第三个参数是一个简易回调实现,用于继续方法调用链。
    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
        @Override
        public Object proceedWithInvocation() throws Throwable {
            return invocation.proceed();
        }
    });
}
```

##### 2.1.2 TransactionAspectSupport#invokeWithinTransaction

这里就是上面TransactionInterceptor调用的invokeWithinTransaction实现，可以将之看作是一个大的环绕切面，将事务的创建与提交/回滚包在事务方法的外围。 

```java
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation) throws Throwable {

    // 获取TransactionAttribute、PlatformTransactionManager、以及连接点方法信息。
    final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
    final PlatformTransactionManager tm = determineTransactionManager(txAttr);
    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
        // Standard transaction demarcation with getTransaction and commit/rollback calls.
        // 根据上面抓取出来的txAttribute, tm, 连接点方法等信息判断是否需要开启事务。
        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
        Object retVal = null;
        try {
            // 执行回调,如果没有后续拦截器的话,就进入事务方法了。
            retVal = invocation.proceedWithInvocation();
        }
        catch (Throwable ex) {
            // 事务发生异常。
            completeTransactionAfterThrowing(txInfo, ex);
            throw ex;
        }
        finally {
            // 把上一层事务的TxInfo重新绑到ThreadLocal中。
            cleanupTransactionInfo(txInfo);
        }
        // 事务未发生异常。
        commitTransactionAfterReturning(txInfo);
        return retVal;
    }
```

##### 2.1.3 TransactionAspectSupport#createTransactionIfNecessary

```java
protected TransactionInfo createTransactionIfNecessary( PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {

    // 如果事务属性中name为null,则创建一个简易委托类,name为连接点方法标识。
    if (txAttr != null && txAttr.getName() == null) {
        txAttr = new DelegatingTransactionAttribute(txAttr) {
            @Override
            public String getName() {
                return joinpointIdentification;
            }
        };
    }

    TransactionStatus status = null;
    if (txAttr != null) {
        if (tm != null) {
            // 根据事务属性判断是否需要开启事务,并返回状态。
            status = tm.getTransaction(txAttr);
        }
        else {
            if (logger.isDebugEnabled()) {
                logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
                        "] because no transaction manager has been configured");
            }
        }
    }
    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}



protected TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm,
        TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) {

    TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
    // 事务方法。
    if (txAttr != null) {
        if (logger.isTraceEnabled()) {
            logger.trace("Getting transaction for [" + txInfo.getJoinpointIdentification() + "]");
        }
        // The transaction manager will flag an error if an incompatible tx already exists.
        txInfo.newTransactionStatus(status);
    }
    else {
        // 非事务方法。
        if (logger.isTraceEnabled())
            logger.trace("Don't need to create transaction for [" + joinpointIdentification +
                    "]: This method isn't transactional.");
    }

    // 无论是否创建了新事务,这里都会把当前的txInfo对象通过threadLocal变量绑定到当前线程。
    txInfo.bindToThread();
    return txInfo;
}
```

#### 2.2 事务的管理--AbstractPlatformTransactionManager

AbstractPlatformTransactionManager是各种事务管理器的抽象基类，也可以说是骨架。它封装了很多事务管理的流程代码，子类需要实现一些模板方法。下面列出一些主要的模板方法。 

- doGetTransaction
  用于从TxMgr中拿一个事务对象，事务对象具体什么类型AbstractPlatformTransactionManager并不care。如果当前已经有事务的话，返回的对象应该是要包含当前事务信息的。
- isExistingTransaction
  用于判断一个事务对象是否对应于一个已经存在的事务。Spring会根据这个方法的返回值来分类讨论事务该如何传播。
- doBegin
  物理开启事务。
- doSuspend
  将当前事务资源挂起。对于我们常用的DataSourceTransactionManager，它的资源就是ConnectionHolder。会将ConnectionHolder与当前线程脱钩并取出来。
- doResume
  恢复当前事务资源。对于我们常用的DataSourceTransactionManager，它会将ConnectionHolder重新绑定到线程上。
- doCommit
  物理提交事务。
- doRollback
  物理回滚事务。
- doSetRollbackOnly
  给事务标记为回滚。对于我们常用的DataSourceTransactionManager，它的实现是拿出事务对象中的ConnectionHolder打上回滚标记。这个标记是一种“全局的标记”，因为隶属于同一个物理事务都能读到同一个ConnectionHolder。

我们首先从上面createTransactionIfNecessary方法中调用到的getTransaction方法开始看起。 

```java
public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {
    // 根据具体的tm实现获取一个transaction对象。
    Object transaction = doGetTransaction();

    boolean debugEnabled = logger.isDebugEnabled();

    if (definition == null) {
        definition = new DefaultTransactionDefinition();
    }

    // 已经存在事务的情况。
    if (isExistingTransaction(transaction)) {
        return handleExistingTransaction(definition, transaction, debugEnabled);
    }

    // timeout不能小于-1。
    if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
        throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());
    }

    // 如果传播行为是MANDATORY,则应该抛出异常(因为此时不存在事务)
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
        throw new IllegalTransactionStateException(
                "No existing transaction found for transaction marked with propagation 'mandatory'");
    }
    // 传播行为是REQUIRED, REQUIRES_NEW, NESTED。
    else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        SuspendedResourcesHolder suspendedResources = suspend(null);
        if (debugEnabled) {
            logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);
        }
        try {
            boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
            // 注意这里的newTransaction标识位是true。
            DefaultTransactionStatus status = newTransactionStatus(
                    definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
            // 调用供子类实现的模板方法doBegin来开启事务。
            doBegin(transaction, definition);
            // 调用TransactionSynchronizationManager来保存一些事务上下文信息。
            prepareSynchronization(status, definition);
            return status;
        }
        catch (RuntimeException ex) {
            resume(null, suspendedResources);
            throw ex;
        }
        catch (Error err) {
            resume(null, suspendedResources);
            throw err;
        }
    }
   /*
    * 这里的else分支说明传播行为是SUPPORTS或NOT_SUPPORTED或NEVER,这几种情况对于当前无事务的逻辑都是直接继续运行。
    */
    else {
        // 如果有指定事务隔离级别,则可以打warn日志报出指定隔离级别开启但没有事务的警告。
        if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
            logger.warn("Custom isolation level specified but no actual transaction initiated; " +
                    "isolation level will effectively be ignored: " + definition);
        }
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        // 注意这里的transaction传的是null，这在尝试commit的时候会判断出其实没有实际需要提交的事务。
        return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
    }
}

/**
 * prepareSynchronization方法根据status是否需要维护新的事务相关资源，信息与回调。
 */
protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {
    if (status.isNewSynchronization()) {
        TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());
        TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(
                definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?
                definition.getIsolationLevel() : null);
        TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
        TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());
        TransactionSynchronizationManager.initSynchronization();
    }
}
```

#### 2.3事务的挂起与恢复--suspend & resume方法

##### 2.3.1事物的挂起 -- suspend方法

```java
/**
 * 本方法做的事情主要就是抓取当前事务资源,事务基本信息以及事务回调transaction synchronization等塞到SuspendedResourcesHolder中返回。
 */
protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {
    /*
     * 在TransactionSynchronizationManager的JavaDoc上已经写明了在需要进行transaction synchronization注册的时候需要先检查当前线程是否激活
     * isSynchronizationActive是去读TransactionSynchronizationManager中当前线程绑定的TransactionSynchronization集合是否为null。
     */
    if (TransactionSynchronizationManager.isSynchronizationActive()) {
        // 对所有本线程当前注册的transaction synchronization调用suspend方法。
        List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization();
        try {
            Object suspendedResources = null;
            if (transaction != null) {
                // 挂起当前事务，由具体的TxMgr子类实现。
                suspendedResources = doSuspend(transaction);
            }

            /*
             * 将当前线程绑定的事务名,是否只读,隔离级别,是否有实际事务等信息抓取出来。
             * 与刚才抓取出来的transaction synchronization集合一起包到SuspendedResourcesHolder中返回。
             */
            String name = TransactionSynchronizationManager.getCurrentTransactionName();
            TransactionSynchronizationManager.setCurrentTransactionName(null);
            boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
            Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
            boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
            TransactionSynchronizationManager.setActualTransactionActive(false);
            return new SuspendedResourcesHolder(
                    suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
        }
        catch (RuntimeException ex) {
            // 恢复transaction synchronization。
            doResumeSynchronization(suspendedSynchronizations);
            throw ex;
        }
        catch (Error err) {
            // 恢复transaction synchronization。
            doResumeSynchronization(suspendedSynchronizations);
            throw err;
        }
    }
    else if (transaction != null) {
        // 挂起当前事务。
        Object suspendedResources = doSuspend(transaction);
        return new SuspendedResourcesHolder(suspendedResources);
    }
    else {
        // 啥都没有。
        return null;
    }
}
private List<TransactionSynchronization> doSuspendSynchronization() {
    // getSynchronizations返回的是一个不可变的快照。
    List<TransactionSynchronization> suspendedSynchronizations =
        TransactionSynchronizationManager.getSynchronizations();
    // 逐一挂起。
    for (TransactionSynchronization synchronization : suspendedSynchronizations) {
        synchronization.suspend();
    }
    // 清理之后除非重新init否则无法再register新的transaction synchronization了。
    TransactionSynchronizationManager.clearSynchronization();
    return suspendedSynchronizations;
}
```

##### 2.3.2 事务的恢复-resume方法

```java
protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) throws TransactionException {
    if (resourcesHolder != null) {
        Object suspendedResources = resourcesHolder.suspendedResources;
        if (suspendedResources != null) {
            // 恢复挂起的事务资源，由具体的TxMgr子类实现。
            doResume(transaction, suspendedResources);
        }
        List<TransactionSynchronization> suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;
        if (suspendedSynchronizations != null) {
            // 还原挂起的事务的一些信息。
            TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);
            TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);
            // 恢复挂起的transaction syncrhonization。
            doResumeSynchronization(suspendedSynchronizations);
        }
    }
}

/**
 * 重新初始化当前线程维护的synchronization集合,逐一对这些synchronization调用resume方法并加入到集合中。
 */
private void doResumeSynchronization(List<TransactionSynchronization> suspendedSynchronizations) {
    TransactionSynchronizationManager.initSynchronization();
    for (TransactionSynchronization synchronization : suspendedSynchronizations) {
        synchronization.resume();
        TransactionSynchronizationManager.registerSynchronization(synchronization);
    }
}
```

#### 2.4 事务的提交与回滚--commit&rollback

commit与rollback两个方法是PlatformTransactionManager接口两个关键方法。 一般在事务切面增强的方法成功情况下会调用commit方法。在事务发生异常后，completeTransactionAfterThrowing方法会根据异常与事务规则是否匹配来决定是否需要回滚。如果需要回滚则调用rollback方法。 

**需要注意的是commit/rollback方法只是尝试，Spring会根据事务状态信息来具体处理,不代表一定会物理提交/回滚，Spring会在事务最外层边界才可能触发物理提交/回滚，甚至也有可能调用commit后发现需要rollback。** 

##### 2.4.1 事务的提交--commit方法

```java
public final void commit(TransactionStatus status) throws TransactionException {
    // 如果事务已经完成了,则抛出异常。
    if (status.isCompleted()) {
        throw new IllegalTransactionStateException(
                "Transaction is already completed - do not call commit or rollback more than once per transaction");
    }

    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    /*
     * 通过前文的源码分析可以知道无论事务怎么传播,每一次进入事务拦截器,在进入业务方法之前都会把一个TransactionInfo对象塞到
     * transactionInfoHolder这个线程本地变量中。而TransactionInfo包含了一个TransactionStatus对象。
     * commit方法是在业务方法正常完成后调用的,所谓isLocalRollbackOnly就是读当前TransactionStatus对象中的rollbackOnly标志位。
     * 正如其名,它是一个局部的标志位，只有创建该status的那一层在业务方法执行完毕后会读到本层status的这个局部标志位。
     *
     * 我们可以在用户代码(业务方法或者切面)中通过TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
     * 来置当前事务层的status对象的rollbackOnly标志位为true以手动控制回滚。
     */
    if (defStatus.isLocalRollbackOnly()) {
        if (defStatus.isDebug()) {
            logger.debug("Transactional code has requested rollback");
        }
        processRollback(defStatus);
        return;
    }
    /*
     * shouldCommitOnGlobalRollbackOnly默认实现是false。
     * 这里判断的语义就是如果发现事务被标记全局回滚并且在全局回滚标记情况下不应该提交事务的话,则进行回滚。
     *
     * 我们通常用的DataSourceTransactionManager对于isGlobalRollbackOnly的判断是去读status中transaction对象的ConnectionHolder的rollbackOnly标志位。
     */
    if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {
        if (defStatus.isDebug()) {
            logger.debug("Global transaction is marked as rollback-only but transactional code requested commit");
        }
        processRollback(defStatus);
        /*
         * isNewTransaction用来判断是否是最外层(事务边界)。
         * 举个例子:传播行为REQUIRE方法调REQUIRE方法再调REQUIRE方法,第三个方法抛出异常,第二个方法捕获,第一个方法走到这里会发现到了最外层事务边界。
         * 而failEarlyOnGlobalRollbackOnly是一个标志位,如果开启了则会尽早抛出异常。
         *
         * 默认情况下failEarlyOnGlobalRollbackOnly开关是关闭的。这样如果内层事务发生了异常,退栈到外层事务后，代码走到这里回滚完后会抛出UnexpectedRollbackException。
         */
        if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
            throw new UnexpectedRollbackException(
                    "Transaction rolled back because it has been marked as rollback-only");
        }
        return;
    }

    processCommit(defStatus);
}

private void processCommit(DefaultTransactionStatus status) throws TransactionException {
    try {
        boolean beforeCompletionInvoked = false;
        try {
            // 钩子函数，TxMgr子类可以覆盖默认的空实现。
            prepareForCommit(status);
            // 回调transaction synchronization的beforeCommit方法。
            triggerBeforeCommit(status);
            // 回调transaction synchronization的beforeCompletion方法。
            triggerBeforeCompletion(status);
            beforeCompletionInvoked = true;
            boolean globalRollbackOnly = false;
            if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
                globalRollbackOnly = status.isGlobalRollbackOnly();
            }
            if (status.hasSavepoint()) {
                if (status.isDebug()) {
                    logger.debug("Releasing transaction savepoint");
                }
                status.releaseHeldSavepoint();
            }
            // 最外层事务边界。
            else if (status.isNewTransaction()) {
                if (status.isDebug()) {
                    logger.debug("Initiating transaction commit");
                }
                // 由具体TxMgr子类实现。
                doCommit(status);
            }
            /*
             * 我们一般用的DataSourceTransactionManager是不会走到这里的。
             * 因为默认shouldCommitOnGlobalRollbackOnly开关是关闭的,检测到golobalRollbackOnly是不会走到processCommit方法的。
             *
             * 但shouldCommitOnGlobalRollbackOnly这个开关对于JtaTransactionManager来说是默认开启的,这里主要是需要针对检测到globalRollbackOnly但是doCommit没有抛出异常的情况。
             */
            if (globalRollbackOnly) {
                throw new UnexpectedRollbackException(
                        "Transaction silently rolled back because it has been marked as rollback-only");
            }
        }
        catch (UnexpectedRollbackException ex) {
            // 回调transaction synchronization的afterCompletion方法。
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
            throw ex;
        }
        catch (TransactionException ex) {
            // doCommit发生异常后，根据rollbackOnCommitFailure开关决定是否回滚,此开关默认关闭。
            if (isRollbackOnCommitFailure()) {
                doRollbackOnCommitException(status, ex);
            }
            else {
                // 回调transaction synchronization的afterCompletion方法。
                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            }
            throw ex;
        }
        catch (RuntimeException ex) {
            if (!beforeCompletionInvoked) {
                triggerBeforeCompletion(status);
            }
            doRollbackOnCommitException(status, ex);
            throw ex;
        }
        catch (Error err) {
            if (!beforeCompletionInvoked) {
                triggerBeforeCompletion(status);
            }
            doRollbackOnCommitException(status, err);
            throw err;
        }

        try {
            // 回调transaction synchronization的afterCommit方法。
            triggerAfterCommit(status);
        }
        finally {
            // 回调transaction synchronization的afterCompletion方法。
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
        }

    }
    finally {
        // 后续工作:status标记completed,在最外层清空transaction synchronization集合，恢复挂起事务资源等等。
        cleanupAfterCompletion(status);
    }
}
```

##### 2.4.2 事务的回滚--rollback方法

AbstractPlatformTransactionManager#rollback方法，否则调用commit方法。 

```java
public final void rollback(TransactionStatus status) throws TransactionException {
    if (status.isCompleted()) {
        throw new IllegalTransactionStateException(
                "Transaction is already completed - do not call commit or rollback more than once per transaction");
    }

    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    processRollback(defStatus);
}

private void processRollback(DefaultTransactionStatus status) {
    try {
        try {
            // 回调transaction synchronization对象的beforeCompletion方法。
            triggerBeforeCompletion(status);
            if (status.hasSavepoint()) {
                if (status.isDebug()) {
                    logger.debug("Rolling back transaction to savepoint");
                }
                status.rollbackToHeldSavepoint();
            }
            // 在最外层事务边界进行回滚。
            else if (status.isNewTransaction()) {
                if (status.isDebug()) {
                    logger.debug("Initiating transaction rollback");
                }
                // 由具体TxMgr子类实现回滚。
                doRollback(status);
            }
            else if (status.hasTransaction()) {
                /*
                 * 内层事务被标记为rollBackOnly或者globalRollbackOnParticipationFailure开关开启时,给当前事务标记需要回滚。
                 * 
                 * 如果内层事务显式打上了rollBackOnly的标记,最终全事务一定是回滚掉的。
                 * 
                 * 但如果没有被打上rollBackOnly标记,则globalRollbackOnParticipationFailure开关就很重要了。
                 * globalRollbackOnParticipationFailure开关默认是开启的，也就是说内层事务挂了,最终的结果只能是全事务回滚。
                 * 但如果globalRollbackOnParticipationFailure开关被关闭的话,内层事务挂了,外层事务业务方法中可以根据情况控制是否回滚。
                 */
                if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
                    if (status.isDebug()) {
                        logger.debug("Participating transaction failed - marking existing transaction as rollback-only");
                    }
                    // 由具体TxMgr子类实现回滚。
                    doSetRollbackOnly(status);
                }
                else {
                    if (status.isDebug()) {
                        logger.debug("Participating transaction failed - letting transaction originator decide on rollback");
                    }
                }
            }
            else {
                logger.debug("Should roll back transaction but cannot - no transaction available");
            }
        }
        catch (RuntimeException ex) {
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            throw ex;
        }
        catch (Error err) {
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            throw err;
        }
        // 回调transaction synchronization对象的afterCompletion方法。
        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
    }
    finally {
        // 后续工作:status标记completed,在最外层清空transaction synchronization集合，恢复挂起事务资源等等。
        cleanupAfterCompletion(status);
    }
}
```

### 3. 案例分析

##### 3.1 进不了事务

这个问题也是使用Spring声明式事务很常见的问题。
首先保证配置都是正确的，并且开启了Spring事务(比如`@EnableTransactionManagement`)。

要明白进事务的本质就是进到事务切面的代理方法中，最常见的是同一个类的非事务方法调用一个加了事务注解的方法没进入事务。
我们以cglib代理为例，由于Spring的对于cglib AOP代理的实现，进入被代理方法的时候实际上已经离开了“代理这一层壳子”，可以认为代码走到的是一个朴素的bean，调用同一个bean中方法自然与代理没有半毛钱关系了。
一般对于声明式事务都是以调用另一个类的加了`@Transactional`注解的public方法作为入口的。

