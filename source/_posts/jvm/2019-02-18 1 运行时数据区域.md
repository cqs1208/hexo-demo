---
layout: post
title: 1 运行时数据区域
tags:
- jvm
categories: jvm
description: jvm
---

虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！ 

<!-- more --> 

## 1 运行时数据区 

**JVM的逻辑内存模型**

![jvm逻辑内存](/images/jvm/jvm逻辑内存.jpg)

### 1.1 程序计数器

	程序计数器也叫pc寄存器。java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的pc (program counter)寄存器。在任意时刻，一条java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法（current method） 如果这个方法不是native的，那pc寄存器就保存Java虚拟机正在执行的字节码指令的地址，如果该方法是native的，那pc寄存器的值就是undefined。pc寄存器的容量至少应当能保存一个returnAddress类型（returnAddress 类型的值指向一条虚拟机指令的操作码）的数据或者一个与品台相关的本地指针的值

### 1.2 Java虚拟机栈

	每一条Java虚拟机线程都有自己私有的Java虚拟机栈（Java Virtual Machine Stack），这个栈与线程同时创建，用于存储栈帧。Java虚拟机栈的作用与传统语言中的栈非常类似，用于存储局部变量与一些尚未计算好的结果。另外它在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配，Java虚拟机栈所使用的内存不需要保证是连续的。

	Java虚拟机规范既允许Java虚拟机栈被实现成固定大小，也允许根据计算动态来扩展和收缩。如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。

> java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机初始容量的手段，对于可以动态扩展和收缩Java虚拟机栈来说，则应当提供调节其最大、最小容量的手段

Java虚拟机栈可能发生如下异常情况：

- 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。

### 1.3 堆 

	在Java虚拟机中，堆（heap）是可提供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。

	Java对在虚拟机启动时就被创建，它存储了被自动内存管理系统（automatic storage management system 也就是常说的garbage collector（垃圾收集器））所管理的各种对象，这些受管理的对象无需也无法显示地销毁。本规范中所描述的Java虚拟机并未假设采用何种具体技术去实现自动内存管理系统。虚拟机实现者可以根据系统的实际需要来选择自动内存管理。Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java对所使用的内存不需要保证是连续的。

> Java虚拟机实现应当提供给程序员或者最终用户调节Java堆初始容量的手段，对于可以动态扩展和收缩Java堆来说，则应当提供调节其最大，最小容量的手段。

Java堆可能发生如下异常情况：

- 如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那么Java虚拟机将会抛出一个OutOfMemoryError异常。

### 1.4 方法区

	在Java虚拟机中，方法区（method area）是可提供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区（storage area for compiled code）或者操作系统进程的正文段（text segment）的作用非常类似，它存储了每一个类的结构信息，例如，运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容。还包括一些在类、实例、接口初始化时用到的特殊方法

	方法区在虚拟机启动时创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存中可以是不连续的。

> Java 虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段

方法区可能发生如下异常情况：

- 如果方法区的内存空间不能满足内存分配请求，那么Java虚拟机将抛出一个OutOfMemoryerror异常

### 1.5 运行时常量池

	运行时常量池是方法区的一部分。
	 CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
	 运行时常量池相对于CLass文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。

### 1.6 本地方法栈

Java虚拟机实现可能会使用到传统的栈（通常称为C stack）来支持native方法（指使用Java以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（native method stack）。当Java虚拟机使用其他语言（例如C语言）来实现指令集解释器时，也可以使用本地方法栈。如果Java虚拟机不支持native方法，或是本身不依赖传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。

	Java虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩，如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。

> Java虚拟机实现应当提供给程序员或者最终用户调节本地方法栈初始容量的手段，对于长度可动态变化的本地方法栈来说，则应当提供调节其最大、最小容量的手段

本地方法栈可能发生如下异常情况：

- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建的线程时没有足够的内存去创建对应的方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。



[参考链接](https://www.cnblogs.com/dingyingsi/p/3760447.html)

[参考链接](https://www.jianshu.com/p/7e914160b594)