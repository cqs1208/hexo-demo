---
layout: post
title: 16 线程池源码分析（java8）
tags:
- JUC
categories: JUC
description: 并发编程
---

java线程的创建、销毁和线程减切换是一件比较耗费计算机资源的事。

<!-- more --> 

如果我们需要用多线程处理任务，并频繁的创建、销毁线程会造成计算机资源的无端浪费，因此出现了线程池技术。 

### 1 线程池类图

![executor类图](/images/JUC/JUC_executor.jpg)

**概括一下：**

- Executor是最基础的执行接口；
- ExecutorService接口继承了Executor在其上做了一些shutdown()submit()的扩展可以说是真正的线程池接口；
- AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；
- TheadPoolExecutor继承了AbstractExecutorService，是线程池的具体实现；
- ScheduledExecutorService接口继承了ExecutorService接口，提供了带"周期执行"功能ExecutorService；
- ScheduledThreadPoolExecutor既继承了TheadPoolExecutor线程池也实现了ScheduledExecutorService接口，是带"周期执行"功能的线程池；
- Executors是线程池的静态工厂，其提供了快捷创建线程池的静态方法。

####1.1 Executor接口

```java
void execute(Runnable command);
```

#### 1.2  **ExecutorService接口**

```java
public interface ExecutorService extends Executor {

    // 启动一个关闭命令，不再接受新任务
    // 当所有已提交任务执行完后，就关闭
    // 如果已经关闭，则调用没有其他作用
    void shutdown();

    // 试图停止所有正在执行的活动任务，暂停处理正在等待的任务
    // 并返回等待执行的任务列表
    List<Runnable> shutdownNow();

    boolean isShutdown();
    boolean isTerminated();

    // 提交任务
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);

    // 批量提交任务
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

#### 1.3 **ScheduledExecutorService接口**

```java
/**
 * 在给定延时后，创建并执行一个一次性的Runnable任务
 * 任务执行完毕后，ScheduledFuture#get()方法会返回null
 */
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
 
/**
 * 在给定延时后，创建并执行一个ScheduledFutureTask
 * ScheduledFuture 可以获取结果或取消任务
 */
public <V> ScheduledFuture<V> schedule(Callable<V> callable, ong delay, TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期
 * 也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 * 如果任何执行的任务超过了周期，随后的执行会延时，不会并发执行
 */
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 */
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);
```

### 2 线程池的使用

#### 2.1 线程池的创建

线程池的创建可以通过创建 `ThreadPoolExecutor` 对象或者调用 `Executors` 的工厂方法来创建线程池。但是在阿里巴巴的java开发手册中提到： 

> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 
> 说明： Executors 返回的线程池对象的弊端如下： 
> 1） FixedThreadPool 和 SingleThreadPool: 
> 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 
> 2） CachedThreadPool 和 ScheduledThreadPool: 
>
> 允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM

#### 2.2 ThreadPoolExecutor

因此先看一下怎么通过创建 `ThreadPoolExecutor` 对象来创建一个线程池。 

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) 
```

这是 ThreadPoolExecutor 的构造方法，其中的参数含义如下：

- corePoolSize：核心线程池大小， 当新的任务到线程池后，线程池会创建新的线程（即使有空闲线程），直到核心线程池已满。
- maximumPoolSize：最大线程池大小，顾名思义，线程池能创建的线程的最大数目
- keepAliveTime：程池的工作线程空闲后，保持存活的时间
- TimeUnit： 时间单位
- BlockingQueue<Runnable>：用来储存等待执行任务的队列
- threadFactory：线程工厂
- RejectedExecutionHandler： 当队列和线程池都满了时拒绝任务的策略

重要参数的说明： 

- corePoolSize 和 maximumPoolSize 

  默认情况下线程中的线程初始时为 0， 当有新的任务到来时才会创建新线程，当线程数目到达 corePoolSize 的数量时，新的任务会被缓存到 workQueue 队列中。如果不断有新的任务到来，队列也满了的话，线程池会再新建线程直到总的线程数目达到 maximumPoolSize。如果还有新的任务到来，则要根据 handler 对新的任务进行相应拒绝处理。

- BlockingQueue<Runnable> 

  一个阻塞队列，用来存储等待执行的任务，常用的有如下几种：

  - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
  - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
  - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
  - PriorityBlockingQueue：一个具有优先级得无限阻塞队列。

- RejectedExecutionHandler 

  当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。有下面四种JDK提供的策略：

  1. AbortPolicy，表示无法处理新任务时抛出异常, 默认策略
  2. CallerRunsPolicy：用调用者所在线程来运行任务。
  3. DiscardOldestPolicy： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。
  4. DiscardPolicy：不处理，丢弃掉 

  除了这些JDK提供的策略外，还可以自己实现 RejectedExecutionHandler 接口定义策略。

#### 2.3 一个创建线程池的小例子： 

```java
public class CreateThreadPool {
    public static void main(String args[]) {
        //不建议的做法
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        //使用 guava 开源框架的 ThreadFactoryBuilder 给线程池的线程设置名字
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(4, 10, 0L,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingDeque<Runnable>(256),
                namedThreadFactory,
                new ThreadPoolExecutor.AbortPolicy());

        pool.execute(() -> System.out.println(Thread.currentThread().getName()));
        pool.execute(() -> System.out.println(Thread.currentThread().getName()));
        pool.execute(() -> System.out.println(Thread.currentThread().getName()));
        pool.shutdown();
    }
}

//输出：
demo-thread-0
demo-thread-1
demo-thread-2
```

### 3 线程池的种类

#### 3.1 SingleThreadExecutor

创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。  

此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory));
    }
```

#### 3.2 FixedThreadPool

创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。  

线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
}
```

示例：

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            pool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + "\t开始发车啦....");
            });
        }
    }
}

返回结果：
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
pool-1-thread-1    开始发车啦....
```

#### 3.3 CachedThreadPool

创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程， 
那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。 

此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小, 极端情况下会因为创建过多线程而耗尽系统资源

```java
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

这里虽然指定 maximumPool 为 `Integer.MAX_VALUE`，但没什么意义，如果不能满足任务执行需求，`CachedThreadPool` 还会继续创建新的线程。 

示例：

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
public class ThreadPool {
    public static void main(String[] args) {
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(10);
        for (int i = 0; i < 10; i++) {
            // 延迟10秒执行任务,如果想要执行周期性的任务可以用下面的方式，每秒执行一次
            pool.schedule(() -> {
                System.out.println(Thread.currentThread().getName() + "\t开始发车啦....");
            }, 10, TimeUnit.SECONDS);
        }
    }
}
```



#### 3.4 ScheduledThreadPool

主要用来在给定的延迟之后运行任务，或者定期执行任务。 

```java
public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
```

#### 3.5 newWorkStealingPool

newWorkStealingPool 是jdk1.8才有的，会根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层用的 ForkJoinPool来实现的。ForkJoinPool 的优势在于，可以充分利用多cpu，多核cpu的优势，把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。

示例：

```java
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
public class Main {
 
	public static void main(String[] args) throws Exception {
		// 设置并行级别为2，即默认每时每刻只有2个线程同时执行
		ExecutorService m = Executors.newWorkStealingPool(2);
		for (int i = 1; i <= 10; i++) {
			final int count=i;
			m.submit(new Runnable() {
				@Override
				public void run() {
					Date now=new Date();
					System.out.println("线程" + Thread.currentThread() + "完成任务："
							+ count+"   时间为："+	now.getSeconds());
					try {
						Thread.sleep(1000);//此任务耗时1s
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
 
			});
           
		}
		while(true){
			//主线程陷入死循环，来观察结果，否则是看不到结果的
		}
	}
}

返回结果：
线程Thread[ForkJoinPool-1-worker-1,5,main]完成任务：1   时间为：7
线程Thread[ForkJoinPool-1-worker-0,5,main]完成任务：2   时间为：7
线程Thread[ForkJoinPool-1-worker-1,5,main]完成任务：3   时间为：8
线程Thread[ForkJoinPool-1-worker-0,5,main]完成任务：4   时间为：8
线程Thread[ForkJoinPool-1-worker-1,5,main]完成任务：5   时间为：9
线程Thread[ForkJoinPool-1-worker-0,5,main]完成任务：6   时间为：9
线程Thread[ForkJoinPool-1-worker-1,5,main]完成任务：7   时间为：10
线程Thread[ForkJoinPool-1-worker-0,5,main]完成任务：8   时间为：10
线程Thread[ForkJoinPool-1-worker-1,5,main]完成任务：9   时间为：11
线程Thread[ForkJoinPool-1-worker-0,5,main]完成任务：10   时间为：11
```

### 4 线程池的拒绝策略

当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。 

- AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。 

  ```java
  public static class AbortPolicy implements RejectedExecutionHandler {
      public AbortPolicy() { }
      public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
          throw new RejectedExecutionException("Task " + r.toString() +
                                                   " rejected from " +
                                                   e.toString());
      }
  }
  ```

- CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。 

  ```java
  public static class CallerRunsPolicy implements RejectedExecutionHandler {
      public CallerRunsPolicy() { }
      public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
          if (!e.isShutdown()) {
                  r.run();
          }
      }
  }
  ```

- DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。 

  ```java
  public static class DiscardOldestPolicy implements RejectedExecutionHandler {
      public DiscardOldestPolicy() { }
      public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
          if (!e.isShutdown()) {
              e.getQueue().poll();
              e.execute(r);
          }
      }
  }
  ```

- DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。 

  ```java
  public static class DiscardPolicy implements RejectedExecutionHandler {
      public DiscardPolicy() { }
      public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
      }
  }
  ```

除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可 

示例：

```java
package org.springframework.integration.util;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class CallerBlocksPolicy implements RejectedExecutionHandler {
    private static final Log logger = LogFactory.getLog(CallerBlocksPolicy.class);
    private final long maxWait;
    /**
     * @param maxWait The maximum time to wait for a queue slot to be
     * available, in milliseconds.
     */
    public CallerBlocksPolicy(long maxWait) {
        this.maxWait = maxWait;
    }
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        if (!executor.isShutdown()) {
            try {
                BlockingQueue<Runnable> queue = executor.getQueue();
                if (logger.isDebugEnabled()) {
                    logger.debug("Attempting to queue task execution for " + this.maxWait + " milliseconds");
                }
                if (!queue.offer(r, this.maxWait, TimeUnit.MILLISECONDS)) {
                    throw new RejectedExecutionException("Max wait time expired to queue task");
                }
                if (logger.isDebugEnabled()) {
                    logger.debug("Task execution queued");
                }
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RejectedExecutionException("Interrupted", e);
            }
        }
        else {
            throw new RejectedExecutionException("Executor has been shut down");
        }
    }
}
```

```java
BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(100);
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10, 100, 10, TimeUnit.SECONDS, workQueue, new CallerBlocksPolicy());
```

### 5 execute和submit的区别

在前面的讲解中，我们执行任务是用的execute方法，除了execute方法，还有一个submit方法也可以执行我们提交的任务。 

#### 5.1 execute 

execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了

```java
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(10);
        pool.execute(() -> {
            System.out.println(Thread.currentThread().getName() + "\t开始发车啦....");
        });
    }
}
```

#### 5.2 submit 

submit方法适用于需要关注返回值的场景，submit方法的定义如下：

```java
public interface ExecutorService extends Executor {
　　...
　　<T> Future<T> submit(Callable<T> task);
　　<T> Future<T> submit(Runnable task, T result);
　　Future<?> submit(Runnable task);
　　...
}
```

其子类AbstractExecutorService实现了submit方法,可以看到无论参数是Callable还是Runnable，最终都会被封装成RunnableFuture，然后再调用execute执行。 

```java
 /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
```

下面我们来看看这三个方法分别如何去使用： 

- **submit(Callable task);** 

  ```java
  public class ThreadPool {
      public static void main(String[] args) throws Exception {
          ExecutorService pool = Executors.newFixedThreadPool(10);
          Future<String> future = pool.submit(new Callable<String>() {
              @Override
              public String call() throws Exception {
                  return "Hello";
              }
          });
          String result = future.get();
          System.out.println(result);
      }
  }
  ```

- **submit(Runnable task, T result);** 

  ```java
  public class ThreadPool {
      public static void main(String[] args) throws Exception {
          ExecutorService pool = Executors.newFixedThreadPool(10);
          Data data = new Data();
          Future<Data> future = pool.submit(new MyRunnable(data), data);
          String result = future.get().getName();
          System.out.println(result);
      }
  }
  class Data {
      String name;
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
  }
  class MyRunnable implements Runnable {
      private Data data;
      public MyRunnable(Data data) {
          this.data = data;
      }
      @Override
      public void run() {
          data.setName("yinjihuan");
      }
  }
  ```

- **Future submit(Runnable task);** 

  ```java
  直接submit一个Runnable是拿不到返回值的，返回值就是null.
  ```

### 6 五种线程池的使用场景

- newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。
- newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。
- newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。
- newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。
- newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。

### 7 线程池的关闭

关闭线程池可以调用shutdownNow和shutdown两个方法来实现 

**shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表** 

```java
public class ThreadPool {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        for (int i = 0; i < 5; i++) {
            System.err.println(i);
            pool.execute(() -> {
                try {
                    Thread.sleep(30000);
                    System.out.println("--");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        Thread.sleep(1000);
        List<Runnable> runs = pool.shutdownNow();
    }
}
```

上面的代码模拟了立即取消的场景，往线程池里添加5个线程任务，然后sleep一段时间，线程池只有一个线程，如果此时调用shutdownNow后应该需要中断一个正在执行的任务和返回4个还未执行的任务，控制台输出下面的内容： 

```java
0
1
2
3
4
[fs.ThreadPool$$Lambda$1/990368553@682a0b20, 
fs.ThreadPool$$Lambda$1/990368553@682a0b20, 
fs.ThreadPool$$Lambda$1/990368553@682a0b20, 
fs.ThreadPool$$Lambda$1/990368553@682a0b20]
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at fs.ThreadPool.lambda$0(ThreadPool.java:15)
    at fs.ThreadPool$$Lambda$1/990368553.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

**shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务** 

```java
public class ThreadPool {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        for (int i = 0; i < 5; i++) {
            System.err.println(i);
            pool.execute(() -> {
                try {
                    Thread.sleep(30000);
                    System.out.println("--");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        Thread.sleep(1000);
        pool.shutdown();
        pool.execute(() -> {
            try {
                Thread.sleep(30000);
                System.out.println("--");
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }
}
```

上面的代码模拟了正在运行的状态，然后调用shutdown，接着再往里面添加任务，肯定是拒绝添加的，请看输出结果： 

```java
0
1
2
3
4
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task fs.ThreadPool$$Lambda$2/1747585824@3d075dc0 rejected from java.util.concurrent.ThreadPoolExecutor@214c265e[Shutting down, pool size = 1, active threads = 1, queued tasks = 4, completed tasks = 0]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
    at fs.ThreadPool.main(ThreadPool.java:24)
```

还有一些业务场景下需要知道线程池中的任务是否全部执行完成，当我们关闭线程池之后，可以用isTerminated来判断所有的线程是否执行完成，千万不要用isShutdown，isShutdown只是返回你是否调用过shutdown的结果。 

```java
public class ThreadPool {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        for (int i = 0; i < 5; i++) {
            System.err.println(i);
            pool.execute(() -> {
                try {
                    Thread.sleep(3000);
                    System.out.println("--");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        Thread.sleep(1000);
        pool.shutdown();
        while(true){  
            if(pool.isTerminated()){  
                System.out.println("所有的子线程都结束了！");  
                break;  
            }  
            Thread.sleep(1000);    
        }  
    }
}
```





[参考链接](https://mp.weixin.qq.com/s/5dexEENTqJWXN_17c6Lz6A)