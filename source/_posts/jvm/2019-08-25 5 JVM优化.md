---
layout: post
title: JVM性能调优
tags:
- jvm
categories: jvm
description: jvm
---

JVM性能调优

<!-- more --> 

## 1 JVM运行参数

### 1.1 标准参数 

```shell
-help
-server -client   ## 模式
-version -showversion
-cp -classpath
```

### 1.2 非标准

#### 1 X参数

 **java -X ** 指令

```java
admindembp-4:tmp admin$ java -X
    -Xmixed           混合模式执行 (默认)
    -Xint             仅解释模式执行
    -Xbootclasspath:<用 : 分隔的目录和 zip/jar 文件>
                      设置搜索路径以引导类和资源
    -Xbootclasspath/a:<用 : 分隔的目录和 zip/jar 文件>
                      附加在引导类路径末尾
    -Xbootclasspath/p:<用 : 分隔的目录和 zip/jar 文件>
                      置于引导类路径之前
    -Xdiag            显示附加诊断消息
    -Xnoclassgc       禁用类垃圾收集
    -Xincgc           启用增量垃圾收集
    -Xloggc:<file>    将 GC 状态记录在文件中 (带时间戳)
    -Xbatch           禁用后台编译
    -Xms<size>        设置初始 Java 堆大小
    -Xmx<size>        设置最大 Java 堆大小
    -Xss<size>        设置 Java 线程堆栈大小
    -Xprof            输出 cpu 配置文件数据
    -Xfuture          启用最严格的检查, 预期将来的默认值
    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)
    -Xcheck:jni       对 JNI 函数执行其他检查
    -Xshare:off       不尝试使用共享类数据
    -Xshare:auto      在可能的情况下使用共享类数据 (默认)
    -Xshare:on        要求使用共享类数据, 否则将失败。
    -XshowSettings    显示所有设置并继续
    -XshowSettings:all
                      显示所有设置并继续
    -XshowSettings:vm 显示所有与 vm 相关的设置并继续
    -XshowSettings:properties
                      显示所有属性设置并继续
    -XshowSettings:locale
                      显示所有与区域设置相关的设置并继续

-X 选项是非标准选项, 如有更改, 恕不另行通知。
```

-Xint  完全解释执行

```java
admindembp-4:tmp admin$ java -showversion -Xint TestJVM
java version "1.8.0_202"
Java(TM) SE Runtime Environment (build 1.8.0_202-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, interpreted mode)
```

-Xcomp : 第一次使用就编译成本地代码

```shell
admindembp-4:tmp admin$ java -showversion -Xcomp TestJVM
java version "1.8.0_202"
Java(TM) SE Runtime Environment (build 1.8.0_202-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, compiled mode)
```

-Xmixed：混合模式，JVM自己来决定是否编译成本地代码(默认)

```shell
admindembp-4:tmp admin$ java -version
java version "1.8.0_202"
Java(TM) SE Runtime Environment (build 1.8.0_202-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)
```

#### 2 XX 参数（使用率较高）

##### 1 Boolean类型

格式：`-XX:[+/-] <name>` 表示启用或者禁用name属性
比如：
`-XX:+UseConcMarkSweepGC` 表示启用CMS垃圾回收器
`-XX:+UseG1GC` 表示启用G1垃圾回收器

##### 2 非Boolean类型

格式：`-XX:<name> = <value>` 表示name属性的值为value
比如：
`-XX:MaxGCPauseMillis=500` 表示GC最大停顿时间是500毫秒
`-XX:GCTimeRatio=19` 表示新生代和老年代的比值

##### 3 -Xmx -Xms

- -Xmx等价于-XX:MaxHeapSize 表示最大堆内存大小，可使用`jinfo -flag MaxHeapSize 进程id`查看，如下：

  ```shell
  [root@izbp12c0zpe8t4yri0xphiz ~]# jinfo -flag MaxHeapSize 22222
  -XX:MaxHeapSize=392167424
  ```

- -Xms等价于-XX:InitalHeapSize 表示堆内存初始大小

- -Xss等价于-XX:InitalStackSize 表示线程栈的初始大小，可以使用`jinfo -flag ThreadStackSize 进程id`查看，如下：

  ```shell
  [root@izbp12c0zpe8t4yri0xphiz ~]# jinfo -flag ThreadStackSize 22222
  -XX:ThreadStackSize=1024
  ```

### 1.3 jps

jps：查看Java进程

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jps
22222 Bootstrap
9407 Jps
[root@izbp12c0zpe8t4yri0xphiz ~]# jps -l
9585 sun.tools.jps.Jps
22222 org.apache.catalina.startup.Bootstrap
```

### 1.4 jinfo

Jinfo: 查看指定Java进程运行时参数

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jinfo -flags 22222
Attaching to process ID 22222, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.51-b03
Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=25165824 -XX:+ManagementServer -XX:MaxHeapSize=392167424 -XX:MaxNewSize=130678784 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=8388608 -XX:OldSize=16777216 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops 
Command line:  -Djava.util.logging.config.file=/usr/local/tomcat-9.0/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=47.96.118.93 -Dcom.sun.management.jmxremote.port=8585 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.net.preferIPv4Stack=true -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dcatalina.base=/usr/local/tomcat-9.0 -Dcatalina.home=/usr/local/tomcat-9.0 -Djava.io.tmpdir=/usr/local/tomcat-9.0/temp
[root@izbp12c0zpe8t4yri0xphiz ~]# 
```

Non-default VM flags`表示手动赋值过的参数，其中有些是tomcat设置的
`

Command line`：与`Non-default VM flags

```shell
#查看某一参数的值，用法：jinfo -flag <参数名> <进程id>
[root@izbp12c0zpe8t4yri0xphiz ~]# jinfo -flag MaxHeapSize 22222
-XX:MaxHeapSize=392167424
```

## 2 JVM内存管理

### 1 jdk内存模型

**jdk1.7的堆内存模型：**

![JVM_heap01](/Users/admin/Desktop/note/images/JVM/JVM_heap01.png)

**1.Young （新生代）**

	新生代 分为三部分。Eden区(new 的对象)和两个大小相同的Survivior区（某一时刻，只有一个被使用），另外一个，当Eden区满了，GC就会将存活的对象移动到空闲的Survivor区，根据JVM的策略，在经过几次垃圾收集后，依然存活在Survivor区的对象，将移动到Tenured区（老年代）

**2.Tenured（老年代）**

	老年代 主要保存生命周期长的对象。（new 的大对象，会直接进入老年代）

**3.Perm（永久代）**

	永久代主要保存class、method、filed对象。这部分的空间一般不会溢出，除非一次性加载很多的类，不过在涉及热部署的应用服务器的时候，有时候会遇到 java.lang.OutOfMemoryError: PermGen space的错误

**jdk1.8的堆内存模型：**

![JVM_heap02](/Users/admin/Desktop/note/images/JVM/JVM_heap02.png)

上图表明，jdk1.8的内存模型有2部分：年轻代+老年代

年轻代：Eden + 2*Survivor （Survivor from + Survivor to）

老年代： OldGen

在jdk1.8中变化最大是 Perm（永久区），用 Metaspace（元数据空间）进行替换

**注：Metaspace所占用的内存空间不是虚拟机内部的，而是本地内存空间。**

![JVM_heap03](/Users/admin/Desktop/note/images/JVM/JVM_heap03.png)

**为什么要废除1.7的永久区？**

1. 在jdk1.8之前的HotSpot实现中，类的元数据 如 方法数据、方法信息（字节码、栈和变量的大小）、运行时常量池等被保存在永久代，32位默认永久代大小为64M，64位默认85M，可以通过参数 -XX：MaxPermSize进行设置，一旦类的元数据超过了永久代的大小，就会抛出OOM（内存过大，虚拟机死掉了）异常。
2. 对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数，常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。
3. 而在jdk1.8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
4. 官网给的解释：为了融合HotSpot JVM 与 JRockit VM ，因为JRockit VM没有永久代，不需要配置永久代。

### 2 jstat

jstat查看虚拟机统计信息

#### 2.1 -class类装载

jstat -class 进程id 每隔多少毫秒 一共输出多少次

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -class 22222
Loaded  Bytes  Unloaded  Bytes     Time   
 16574 31245.0      401   614.2      94.22
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -class 22222 1000 5
Loaded  Bytes  Unloaded  Bytes     Time   
 16574 31245.0      401   614.2      94.22
 16574 31245.0      401   614.2      94.22
 16574 31245.0      401   614.2      94.22
 16574 31245.0      401   614.2      94.22
 16574 31245.0      401   614.2      94.22
[root@izbp12c0zpe8t4yri0xphiz ~]# 
```

- Loaded：表示类加载的个数
- Bytes：表示类加载的大小，单位为kb
- UnLoaded：表示类卸载的个数
- Bytes：表示类卸载的大小，单位为kb
- Time：表示类加载和卸载的时间

#### 2.2 JIT编译

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -compiler 22222 
Compiled Failed Invalid   Time   FailedType FailedMethod
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -compiler 22222 1000 5
Compiled Failed Invalid   Time   FailedType FailedMethod
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
   19594      3       0   125.64          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
[root@izbp12c0zpe8t4yri0xphiz ~]# 
```

- Compiled：表示编译成功的方法数量
- Failed：表示编译失败的方法数量
- Invalid：表示编译无效的方法数量
- Time：编译所花费的时间
- FailedType：编译失败类型
- FailedMethod：编译失败方法

#### 2.3 垃圾收集

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -gc 22222 
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
6144.0 6144.0 1735.3  0.0   49408.0  42161.3   123300.0   75752.0   95920.0 93351.3 11440.0 10883.2   3762   34.124  12      2.742   36.866
[root@izbp12c0zpe8t4yri0xphiz ~]# jstat -gc 22222 1000 4
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
6144.0 6144.0 1735.3  0.0   49408.0  42430.0   123300.0   75752.0   95920.0 93351.3 11440.0 10883.2   3762   34.124  12      2.742   36.866
6144.0 6144.0 1735.3  0.0   49408.0  42430.0   123300.0   75752.0   95920.0 93351.3 11440.0 10883.2   3762   34.124  12      2.742   36.866
6144.0 6144.0 1735.3  0.0   49408.0  42430.0   123300.0   75752.0   95920.0 93351.3 11440.0 10883.2   3762   34.124  12      2.742   36.866
6144.0 6144.0 1735.3  0.0   49408.0  42430.0   123300.0   75752.0   95920.0 93351.3 11440.0 10883.2   3762   34.124  12      2.742   36.866
[root@izbp12c0zpe8t4yri0xphiz ~]# 
```

- S0C`: Current survivor space 0 capacity (kB).`表示survivor 0区的总大小
- S1C`: Current survivor space 1 capacity (kB).`表示survivor 1区的总大小
- S0U`: Survivor space 0 utilization (kB).`表示survivor 0区使用了的大小
- S1U`: Survivor space 1 utilization (kB).`表示survivor 1区使用了的大小
- EC`: Current eden space capacity (kB).`表示eden区总大小
- EU`: Eden space utilization (kB).`表示eden区使用了的大小
- OC`: Current old space capacity (kB).`表示old区总大小
- OU`: Old space utilization (kB).`表示old区使用了的大小
- MC`: Metaspace capacity (kB).`表示Metaspace区总大小
- MU`: Metacspace utilization (kB).`表示Metaspace区使用了的大小
- CCSC`: Compressed class space capacity (kB).`表示压缩类空间总量
- CCSU`: Compressed class space used (kB).`表示压缩类空间使用量
- YGC`: Number of young generation garbage collection events.`表示Young GC的次数
- YGCT`: Young generation garbage collection time.`表示Young GC的时间
- FGC`: Number of full GC events.`表示full GC的次数
- FGCT`: Full garbage collection time.`表示full GC的时间
- GCT`: Total garbage collection time.`表示总的 GC的时间

## 3 jmap使用

### 1 查看内存使用

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jmap -heap 22222
Attaching to process ID 22222, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.51-b03

using thread-local object allocation.
Mark Sweep Compact GC

Heap Configuration:
   MinHeapFreeRatio         = 40
   MaxHeapFreeRatio         = 70
   MaxHeapSize              = 392167424 (374.0MB)
   NewSize                  = 8388608 (8.0MB)
   MaxNewSize               = 130678784 (124.625MB)
   OldSize                  = 16777216 (16.0MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:   # 堆内存使用情况
New Generation (Eden + 1 Survivor Space):
   capacity = 56885248 (54.25MB)
   used     = 38070792 (36.30713653564453MB)
   free     = 18814456 (17.94286346435547MB)
   66.92559730072725% used
Eden Space:
   capacity = 50593792 (48.25MB)
   used     = 36255304 (34.57575225830078MB)
   free     = 14338488 (13.674247741699219MB)
   71.6595901726441% used
From Space:
   capacity = 6291456 (6.0MB)
   used     = 1815488 (1.73138427734375MB)
   free     = 4475968 (4.26861572265625MB)
   28.856404622395832% used
To Space:
   capacity = 6291456 (6.0MB)
   used     = 0 (0.0MB)
   free     = 6291456 (6.0MB)
   0.0% used
tenured generation:
   capacity = 126259200 (120.41015625MB)
   used     = 77610680 (74.01531219482422MB)
   free     = 48648520 (46.39484405517578MB)
   61.46932659164639% used

31382 interned Strings occupying 3662056 bytes.
[root@izbp12c0zpe8t4yri0xphiz ~]# 
```

### 2 查看内存中对象

查看所有对象，包括活跃和非活跃

```shell
jmap -histo <pid> | more
```

查看活跃对象

```shell
jmap -histo:live <pid> | more
```



```shell

[root@izbp12c0zpe8t4yri0xphiz ~]# jmap -histo 22222 | more

 num     #instances         #bytes  class name
----------------------------------------------
   1:        276783       39450176  [C
   2:         73182       20722440  [B
   3:        268555        6445320  java.lang.Double
   4:        159548        6381920  java.util.TreeMap$Entry
   5:        230993        5543832  java.lang.String
   6:         38000        3344000  java.lang.reflect.Method
   7:        134275        3222600  org.jfree.data.xy.XYDataItem
   8:         54626        2703784  [Ljava.lang.Object;
   9:         24675        2224360  [I
  10:         62129        1988128  java.util.concurrent.ConcurrentHashMap$Node
  11:         17188        1908880  java.lang.Class
  12:         86855        1736240  [Ljava.lang.Class;
  13:         17377        1533640  [Ljava.util.HashMap$Node;
  14:         47437        1517984  java.util.HashMap$Node
  15:         27047        1081880  java.util.LinkedHashMap$Entry
  16:         16653         932568  java.util.LinkedHashMap
  17:         51470         823520  java.lang.Integer
  18:         18179         750448  [Ljava.lang.String;
  19:         13853         664944  java.util.HashMap
  20:           494         617184  [Ljava.util.concurrent.ConcurrentHashMap$Node;
  21:         23696         568704  java.util.ArrayList
  23:         30367         485872  java.lang.Object
  24:         15016         480512  java.io.File
  25:         14317         458144  java.util.Hashtable$Entry
  26:         12308         393856  java.lang.ref.WeakReference
  27:          9015         360600  java.util.HashMap$ValueIterator
  28:          7244         347712  org.apache.tomcat.util.buf.ByteChunk
  29:          6707         321936  org.apache.tomcat.util.buf.CharChunk
  30:          6575         315600  org.apache.tomcat.util.buf.MessageBytes
  31:          7651         306040  java.lang.ref.SoftReference
  32:         12396         297504  org.apache.catalina.loader.ResourceEntry
  33:          8341         266912  java.util.LinkedList
  34:          3265         261200  java.lang.reflect.Constructor
  35:          4066         260224  java.util.concurrent.ConcurrentHashMap
  36:          2853         240336  [Ljava.util.WeakHashMap$Entry;
  37:          3301         237672  java.util.regex.Pattern
--More--
```

对象说明

| 对象      | 说明               |
| --------- | ------------------ |
| B         | byte               |
| C         | Char               |
| D         | Double             |
| F         | Float              |
| I         | Int                |
| J         | Long               |
| Z         | Boolean            |
| [         | 数组 如[I表示int[] |
| [L + 类名 | 其它对象           |

### 3 dump到文件

 格式：jmap -dump:format=b,file=dumpFileName <pid>

示例： jmap -dump:format=b,file=/tmp/dump.dump 2642

```shell
[root@izbp12c0zpe8t4yri0xphiz bin]# jmap -dump:format=b,file=/tmp/dump.dump 2642
Dumping heap to /tmp/dump.dump ...
Heap dump file created
[root@izbp12c0zpe8t4yri0xphiz bin]# 
```

### 4 jhat分析dump文件

格式 jhat -port <port> <file>

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jhat -port 8485 /tmp/dump.dump
Reading from /tmp/dump.dump...
Dump file created Sun Aug 04 12:11:17 CST 2019
Snapshot read, resolving...
Resolving 480672 objects...
Chasing references, expect 96 dots................................................................................................
Eliminating duplicate references................................................................................................
Snapshot resolved.
Started HTTP server on port 8485
Server is ready.
```

访问 http://47.96.118.93:8485/

![JVM_heap04](/Users/admin/Desktop/note/images/JVM/JVM_heap04.png)

## 4 jstack 使用

### 4.1  jstack 线程的状态

- RUNNABLE 线程运行中或 I/O 等待 
- BLOCKED 线程在等待 monitor 锁( synchronized 关键字) 
- TIMED_WAITING 线程在等待唤醒，但设置了时限 
- WAITING 线程在无限等待唤醒

### 4.2 死锁实战

**1，构造死锁**

启动两个线程，thread1拿到obj1锁，准备去拿obj2锁，obj2已经被thread2锁定，所以发生了死锁

```shell
public class TestDeadLock {
    private static Object obj1 = new Object();
    private static Object obj2 = new Object();

    public static void main(String[] args) {
        new Thread(new Thread1()).start();
        new Thread(new Thread2()).start();
    }

    private static class Thread1 implements Runnable{
        @Override
        public void run() {
            synchronized (obj1){
                System.out.println("Thread1 拿到了obj1的锁！");
                try{
                    Thread.sleep(2000);
                }catch (Exception e){
                    e.printStackTrace();
                }

                synchronized (obj2){
                    System.out.println("Thread1 拿到了obj2的锁！");
                }
            }
        }
    }

    private static class Thread2 implements Runnable{
        @Override
        public void run() {
            synchronized (obj2){
                System.out.println("Thread2 拿到了obj2的锁！");
                try{
                    Thread.sleep(2000);
                }catch (Exception e){
                    e.printStackTrace();
                }

                synchronized (obj1){
                    System.out.println("Thread2 拿到了obj1的锁！");
                }
            }
        }
    }
}
```

**2，编译运行**

```shell
javac TestDeadLock.java
[root@izbp12c0zpe8t4yri0xphiz local]# java TestDeadLock
Thread1 拿到了obj1的锁！
Thread2 拿到了obj2的锁！
```

**3，使用jstack分析**

```shell
[root@izbp12c0zpe8t4yri0xphiz ~]# jps    # 找到该进程
2642 Bootstrap
17150 Jps
15486 TestDeadLock   

[root@izbp12c0zpe8t4yri0xphiz ~]# jstack -l 15486
2019-08-10 14:58:58
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.51-b03 mixed mode):
......
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00007f3d340062c8 (object 0x00000000e8a58640, a java.lang.Object),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00007f3d34004e28 (object 0x00000000e8a58650, a java.lang.Object),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
	at TestDeadLock$Thread2.run(TestDeadLock.java:42)
	- waiting to lock <0x00000000e8a58640> (a java.lang.Object)
	- locked <0x00000000e8a58650> (a java.lang.Object)
	at java.lang.Thread.run(Thread.java:745)
"Thread-0":
	at TestDeadLock$Thread1.run(TestDeadLock.java:23)
	- waiting to lock <0x00000000e8a58650> (a java.lang.Object)
	- locked <0x00000000e8a58640> (a java.lang.Object)
	at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.
```

从打印的信息中能发现有一个死锁，并知道该问题出现的代码位置`TestDeadLock.java:42`

## 5 JVM 之 GC

JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。

### 5.1 垃圾收集算法

#### 1 引用计数法

**1 算法分析**

引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

**2 优缺点**

**优点**：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

**缺点**：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。

**3 循环引用示例**

```java
public class abc_test {
    public static void main(String[] args) {
        MyObject object1=new MyObject();
        MyObject object2=new MyObject();
        
        object1.object=object2;
        object2.object=object1;
        
        object1=null;
        object2=null;
    }
}
class MyObject{
     MyObject object;
}
```

这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将`object1`和`object2`赋值为`null`，也就是说`object1`和`object2`指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。

#### 2 标记清除算法

**1 分析**

在介绍标记清除算法之前，这里要先提一下可达性分析算法，所谓可达性分析就是用来判断对象是否存活，这个算法的基本思路就是以“GC Roots”（在java中，虚拟机栈中的引用对象，方法区中静态属性引用对象，方法区中常量引用对象，本地方法栈中的JNI都可以最为GC Roots）为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，也就是说从GC Roots到这个对象是不可达的，则这个对象就会被判定为可回收对象。

该算法是将垃圾的回收分为两个阶段，分别为标记和清除，首先是标记，如下图，会采用可达性分析算法，找出可用和不可用的对象，将可用的对象的mark值设置为1，不可用的为0。然后就会进行第二个阶段，也就是清除阶段，这里会把mark为0的对象进行垃圾回收，然后将剩余对象的mark设为0，等待下一次标记

![JVM_GC01](/Users/admin/Desktop/note/images/JVM/JVM_GC01.png)

**2 优缺点**

**优点：**由图中也可以看到该算法解决了引用计数算法中循环引用对象的回收问题

**缺点：**

1. 效率较低，在标记和清除阶段都需要遍历所有的对象，而且在GC的时候会短暂的停止应用程序，用户体验较差
2. 通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的

#### 3 标记压缩算法

**1 分析**

标记压缩算法是在标记清除算法上做了改进和优化，标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。

![JVM_GC02](/Users/admin/Desktop/note/images/JVM/JVM_GC02.png)

**2 优缺点**

**优缺点：**优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。

#### 4 复制算法

**1 分析**

复制算法就是将没存空间一分为二，存储时只使用其中的一块空间，当进行垃圾回收的时候，找出正在使用的对象，并将这些对象复制到另一块内存空间中，然后将该内存清空，交换两个空间的角色，实现垃圾的回收。

在jvm新生代中，Survivor区就是采用复制算法实现的垃圾回收。

1. 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
2. 紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
3. 经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。

GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中

**2 优缺点**

优点：

1.如果垃圾对象较多的情况下，该算法效率比较高

2.垃圾清理之后，内存不会出现碎片化

缺点：

1.并不适用在垃圾较少的情况下适用，例如老年代中

2.分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低

### 5.2 垃圾收集器

#### 1 Serial垃圾收集器

新生代单线程收集器（复制算法)

一个主要应用于Y-GC的垃圾回收器，采用串行单线程的方式完成GC任务，其中“Stop The World"简称STW,即垃圾回收的某个阶段会暂停整个应用程序的执行
F-GC的时间相对较长，频繁FGC会严重影响应用程序的性能

![JVM_GC03](/Users/admin/Desktop/note/images/JVM/JVM_GC03.png)

单线程 Stop-The-World 式

![JVM_GC04](/Users/admin/Desktop/note/images/JVM/JVM_GC04.png)

**特点**

- 单线程
  只会使用一个CPU或一条GC线程进行GC,并且在GC过程中暂停其他所有的工作线程,因此用户的请求或图形化界面会出现卡顿

- 适合Client模式
  一般客户端应用所需内存较小,不会创建太多的对象,而且堆内存不大,因此GC时间比较短,即使在这段时间停止一切用户线程,也不会感到明显停顿

- 简单高效
  由于Serial收集器只有一条GC线程,避免了线程切换的开销

- 采用"复制"算法

**测试**

测试代码：

```java
public class TestGC {
    public static void main(String[] args) throws InterruptedException {
        List<Object> list = new ArrayList<>();
        //实现 不断的产生新的数据，随机的废弃对象
        while(true){
            int sleep = new Random().nextInt(100);
            if(System.currentTimeMillis() % 2 == 0){
                list.clear();
            }else{
                //向List中添加10000个对象
                for(int i = 0; i < 10000; i++){
                    Properties properties = new Properties();
                    properties.put("key_" + i, "value_" + System.currentTimeMillis());
                    list.add(properties);
                }
            }
            Thread.sleep(sleep);
        }
    }
}
```

参数设置：

```shell
-XX:+UseSerialGC -XX:+PrintGCDetails -Xms16m -Xmx16m
```

-XX:+UseSerialGC ： 指定年轻代和老年代都是用串行垃圾收集器

-XX:+PrintGCDetails： 打印垃圾回收的详细信息

日志打印信息：

```shell
[GC (Allocation Failure) [DefNew: 4416K->512K(4928K), 0.0000210 secs][Tenured: 7659K->2264K(10944K), 0.0074938 secs] 12075K->2264K(15872K), [Metaspace: 3159K->3159K(1056768K)], 0.0075593 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
[Full GC (Allocation Failure) [Tenured: 10943K->779K(10944K), 0.0061130 secs] 15871K->779K(15872K), [Metaspace: 3159K->3159K(1056768K)], 0.0061766 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
```

GC日志解读：

- DefNew ： 表示使用的是串行垃圾收集器
- 4416K->512K(4928K)： 表示年轻代GC前，占用4416kb内存，GC后占有4416k内存，总大小4928k
- 0.0000210 secs: 表示GC所用的时间，单位为毫秒
- 7659K->2264K(10944K)： 表示，GC前，堆内存占有7659K，GC后，占有2264K，总大小为10944K
- Full GC： 表示内存空间全部进行GC

#### 2 ParNew垃圾收集器

新生代收集器  (停止-复制算法)　

```shell
 # 参数
-XX:+UseParNewGC -XX:+PrintGCDetails -Xms16m -Xmx16m  

# 打印出的信息
[GC (Allocation Failure) [ParNew: 4416K->512K(4928K), 0.0022062 secs] 4416K->1345K(15872K), 0.0022293 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
```

由以上可知，parNew使用的是ParNew收集器，其它信息和串行收集器一致

#### 3 ParallelGC 垃圾收集器

ParallelGC收集器工作机制和ParNew收集器一样，只是在此基础上，新增了两个和系统吞吐量相关的参数，使其使用起来更加的灵活和高效

相关参数：

- -XX:+UseParallelGC 
  - 年轻代使用的ParallelGC垃圾回收器，老年代使用SerialGC回收器
- -XX:+UseParallelOldGC 
  -  年轻代使用的ParallelGC垃圾回收器，老年代使用ParallelOldGC回收器
- -XX:MaxGCPauseMillis
  - 设置最大的垃圾收集时的停顿时间，单位为毫秒
  - 需要注意的是，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆的大小设置的较小，就会导致GC工作变得很频繁，反而可能会影响到性能
  - 该参数使用需谨慎
- -XX:GCTimeRatio
  - 设置垃圾回收时间占程序时间的百分比，公式为1/（1 + n）
  - 它的值为0-1之间的数字，默认值为99，也就是垃圾回收时间不能超过%

- -XX:UseAdaptiveSizePolicy
  - 自适应GC模式，垃圾回收器将自动调整新生代，老年代等参数，达到吞吐量，堆大小，停顿时间之间的平衡
  - 一般用于，手动调整参数比较困难的场景，让收集器自动进行整理

**测试**

```shell
# 参数
-XX:+UseParallelGC -XX:+UseParallelOldGC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xms16m -Xmx16m

# 打印日志信息
[GC (Allocation Failure) [PSYoungGen: 4096K->512K(4608K)] 4096K->1207K(15872K), 0.0012154 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 483K->0K(2560K)] [ParOldGen: 9879K->3844K(11264K)] 10362K->3844K(13824K), [Metaspace: 3152K->3152K(1056768K)], 0.0104722 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 
```

由以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器

#### 3 CMS垃圾收集器

Concurrent Mark Sweep Collector : 低延迟为先!

回收停顿时间比较短、目前比较常用的垃圾回收器。它通过初始标记(InitialMark)、并发标记(Concurrent Mark)、重新标记( Remark)、并发清除( Concurrent Sweep )四个步骤完成垃圾回收工作
由于CMS采用的是“标记-清除算法"，因此戸生大量的空间碎片。为了解决这个问题，CMS可以通过配置

> -XX:+UseCMSCompactAtFullCollection

参数，强制JVM在FGC完成后対老年代迸行圧縮，执行一次空间碎片整理，但是空间碎片整理阶段也会引发STW。为了减少STW次数，CMS还可以通过配置

> -XX:+CMSFullGCsBeforeCompaction=n

**垃圾回收过程**

前两步需要"Stop The World"

- 初始标记 (Initial Mark)
  停止一切用户线程,仅使用一条初始标记线程对所有与GC Roots直接相关联的 老年代对象进行标记,速度很快

- 并发标记 (Concurrent Marking Phase)
  使用多条并发标记线程并行执行,并与用户线程并发执行.此过程进行可达性分析,标记所有这些对象可达的存货对象,速度很慢

- 重新标记 ( Remark)
  因为并发标记时有用户线程在执行，标记结果可能有变化
  停止一切用户线程,并使用多条重新标记线程并行执行,重新遍历所有在并发标记期间有变化的对象进行最后的标记.这个过程的运行时间介于初始标记和并发标记之间

- 并发清除 (Concurrent Sweeping)
  只使用一条并发清除线程,和用户线程们并发执行,清除刚才标记的对象
  这个过程非常耗时

![JVM_GC05](/Users/admin/Desktop/note/images/JVM/JVM_GC05.png)

缺点：

- 吞吐量低
  由于CMS在GC过程用户线程和GC线程并行,从而有线程切换的额外开销
  因此CPU吞吐量就不如在GC过程中停止一切用户线程的方式来的高

- 无法处理浮动垃圾,导致频繁Full GC
  由于垃圾清除过程中,用户线程和GC线程并发执行,也就是用户线程仍在执行,那么在执行过程中会产生垃圾,这些垃圾称为"浮动垃圾"
  如果CMS在GC过程中,用户线程需要在老年代中分配内存时发现空间不足,就需再次发起Full GC,而此时CMS正在进行清除工作,因此此时只能由Serial Old临时对老年代进行一次Full GC

- 使用"标记-清除"算法产生碎片空间
  由于CMS使用了"标记-清除"算法, 因此清除之后会产生大量的碎片空间,不利于空间利用率.不过CMS提供了应对策略:

  - 开启-XX:+UseCMSCompactAtFullCollection
    开启该参数后,每次FullGC完成后都会进行一次内存压缩整理,将零散在各处的对象整理到一块儿.但每次都整理效率不高,因此提供了以下参数.

  - 设置参数-XX:CMSFullGCsBeforeCompaction
    本参数告诉CMS,经过了N次Full GC过后再进行一次内存整理.

**测试**

```shell
# 设置启动参数
-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xms16m -Xmx16m

# 运行日志
[GC (Allocation Failure) [ParNew: 4416K->512K(4928K), 0.0235669 secs] 4416K->1344K(15872K), 0.0236191 secs] [Times: user=0.02 sys=0.01, real=0.02 secs] 
# 第一步 初始标记
[GC (CMS Initial Mark) [1 CMS-initial-mark: 7577K(10944K)] 8177K(15872K), 0.0010702 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
# 第二步 并发标记
[CMS-concurrent-mark-start]
[CMS-concurrent-mark: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
# 第三步 预处理
[CMS-concurrent-preclean-start]
[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
# 第四步 重新标记
[GC (CMS Final Remark) [YG occupancy: 2098 K (4928 K)][Rescan (parallel) , 0.0004890 secs][weak refs processing, 0.0000713 secs][class unloading, 0.0002386 secs][scrub symbol table, 0.0002982 secs][scrub string table, 0.0001423 secs][1 CMS-remark: 7577K(10944K)] 9676K(15872K), 0.0012986 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
# 第五步 并发清理
[CMS-concurrent-sweep-start]
[CMS-concurrent-sweep: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
# 第六步 重置
[CMS-concurrent-reset-start]
[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
```

#### G1垃圾收集器

G1的设计原则就是简单可行的性能调优

G1将新生代，老年代的物理空间划分取消了。

取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。

![JVM_GC06](/Users/admin/Desktop/note/images/JVM/JVM_GC06.png)

在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个**巨型对象**。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

对象分配策略

说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：

1. TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区
2. Eden区中分配
3. Humongous区分配

TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。

对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。

最后，G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。下面我们将分别介绍一下这2种模式。

**G1 Young GC**

Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

![JVM_GC07](/Users/admin/Desktop/note/images/JVM/JVM_GC07.png)

![JVM_GC08](/Users/admin/Desktop/note/images/JVM/JVM_GC08.png)

**Remembered Set**

这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。

![JVM_GC09](/Users/admin/Desktop/note/images/JVM/JVM_GC09.png)

在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。

但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。

需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

Young GC 阶段：

- 阶段1：根扫描
  静态和本地对象被扫描

- 阶段2：更新RS
  处理dirty card队列更新RS

- 阶段3：处理RS
  检测从年轻代指向年老代的对象

- 阶段4：对象拷贝
  拷贝存活的对象到survivor/old区域

- 阶段5：处理引用队列

  软引用，弱引用，虚引用处理

**G1 Mix GC**

Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。

出发条件：由参数-XX:InitiatingHeapOccupancyPercent=n 决定，默认：45%， 该参数的意思是：当老年代大小占整个堆大小百分比到达该阀值时触发。

它的GC步骤分2步：

1. 全局并发标记（global concurrent marking）
2. 拷贝存活对象（evacuation）

**全局并发标记**

在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：

- 初始标记（initial mark，STW）
  在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。

- 根区域扫描（root region scan）
  G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。

- 并发标记（Concurrent Marking）
  G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断

- 最终标记（Remark，STW）
  该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。

- 清除垃圾（Cleanup，STW）

  在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。

**G1收集相关参数**

- -XX:+UseG1GC
  - 使用G1垃圾收集器

- -XX:MaxGCPauseMillis
  - 设置期望值达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是200毫秒

- -XX:G1HeapRegionSize=n
  - 置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。
  - 默认是堆的1/2000

- -XX:ParallelGCThreads=n
  - 设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8

- -XX:ConcGCThreads=n
  - 设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。

- -XX:InitiatingHeapOccupancyPercent=n
  - 设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。

**测试**

```shell
-XX:+UseG1GC -Xmx32m -XX:MaxGCPauseMillis=200 -XX:+PrintGCDetails

# 日志
[GC pause (G1 Evacuation Pause) (young), 0.0058915 secs]
   [Parallel Time: 5.4 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 609.3, Avg: 609.4, Max: 609.4, Diff: 0.0]
      # 扫描根节点
      [Ext Root Scanning (ms): Min: 0.1, Avg: 0.3, Max: 0.5, Diff: 0.4, Sum: 1.0]
      # 更新RS区域所消耗的时间
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]
      # 对象拷贝
      [Object Copy (ms): Min: 4.1, Avg: 4.1, Max: 4.3, Diff: 0.2, Sum: 16.6]
      [Termination (ms): Min: 0.0, Avg: 0.4, Max: 0.6, Diff: 0.6, Sum: 1.6]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Total (ms): Min: 4.8, Avg: 4.8, Max: 4.9, Diff: 0.0, Sum: 19.4]
      [GC Worker End (ms): Min: 614.2, Avg: 614.2, Max: 614.2, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.0 ms]  # 清空CardTable
   [Other: 0.4 ms]
      [Choose CSet: 0.0 ms] # 选取CSet
      [Ref Proc: 0.3 ms]    # 弱引用、软引用的处理耗时
      [Ref Enq: 0.0 ms]     # 弱引用、软引用的入队耗时
      [Redirty Cards: 0.0 ms]
      [Humongous Register: 0.0 ms]   # 大对象区域注册耗时
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 14.0M(14.0M)->0.0B(16.0M) Survivors: 0.0B->2048.0K Heap: 14.0M(32.0M)->3915.0K(32.0M)]
 [Times: user=0.01 sys=0.00, real=0.00 secs] 
```

## 6 Tomcat 优化

### 1 jmeter对Tomcat测试

启动jmeter, sh jmeter  不修改任何配置启动1000个线程访问十次结果信息

![Tomcat_01](/Users/admin/Desktop/note/images/性能优化/Tomcat_01.png)

### 2 禁用AJP服务

注释server.xml中的AJP配置

> <!-- <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /> -->

![Tomcat_02](/Users/admin/Desktop/note/images/性能优化/Tomcat_02.png)

### 3 设置线程池

Executor 参数解析：

- name="tomcatThreadPool" --线程池名
- namePrefix="catalina-exec-" --线程名称前缀 namePrefix+threaNumber
- maxThreads="1000" --池中最大线程数
- minSpareThreads="100" --活跃线程数 会一直存在
- maxIdleTime="60000" --线程空闲时间，超过该时间，线程会被销毁 ms
- maxQueueSize="Integer.MAX_VALUE" --被执行前线程的排队数目（队列最大等待数）
- prestartminSpareThreads="false" --启动线程池时，是否启用minSpareThreads部分线程
- threadPriority="5" --线程池中线程优先级 1~10
- className="org.apache.catalina.core.StandardThreadExecutor" --线程实现类 自定义线程需时间 org.apache.catalina.Executor类

**线程池配置：**

```shell
<Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
maxThreads="150" minSpareThreads="4"/>
```

**启用线程池：** executor="tomcatThreadPool"

```shell
<Connector executor="tomcatThreadPool"

               port="8080" protocol="HTTP/1.1"

               connectionTimeout="20000"

               redirectPort="8443" />
```

![Tomcat_03](/Users/admin/Desktop/note/images/性能优化/Tomcat_03.png)

### 4 设置nio2的运行模式

> protocol="org.apache.coyote.http11.Http11Nio2Protocol"

```shell
<Connector executor="tomcatThreadPool" port="8080" 
 protocol="org.apache.coyote.http11.Http11Nio2Protocol"
               connectionTimeout="20000"
              redirectPort="8443" />
```

### 5 调整JVM参数进行优化

修改bin 目录下的catalina.sh
添加：JAVA_OPTS='-Xms512m -Xmx1024m '。。。