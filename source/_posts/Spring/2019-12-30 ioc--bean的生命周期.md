---
layout: post
title: ioc--bean的生命周期
tags:
- SpringCore
categories: SpringCore
description: spring源码
---

spring流程执行主要是 **refresh()** 方法

<!-- more --> 

## refresh()方法

```java
//refresh():543, AbstractApplicationContext (org.springframework.context.support) 
public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            //1 刷新前的预处理
            prepareRefresh();
            //2 获取BeanFactory；刚创建的默认DefaultListableBeanFactory
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
            //3 BeanFactory的预准备工作（BeanFactory进行一些设置）
            prepareBeanFactory(beanFactory);

            try {
                // 4 BeanFactory准备工作完成后进行的后置处理工作；
                 // 4.1）、抽象的方法，当前未做处理。子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置
                postProcessBeanFactory(beanFactory);  
        /**************************以上是BeanFactory的创建及预准备工作  ****************/
                
                // 5 执行BeanFactoryPostProcessor的方法；
//BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；
//他的重要两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor
                invokeBeanFactoryPostProcessors(beanFactory);

                //6 注册BeanPostProcessor（Bean的后置处理器）
                registerBeanPostProcessors(beanFactory);

            // 7 initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；
                initMessageSource();

                // 8 初始化事件派发器
                initApplicationEventMulticaster();

                // 9 子类重写这个方法，在容器刷新的时候可以自定义逻辑；
                onRefresh();

                // 10 给容器中将所有项目里面的ApplicationListener注册进来
 
                registerListeners();
       
                // 11.初始化所有剩下的单实例bean；
                finishBeanFactoryInitialization(beanFactory);

                // 12.完成BeanFactory的初始化创建工作；IOC容器就创建完成；
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Exception encountered during context initialization - " +
                            "cancelling refresh attempt: " + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }
        }
    }
```

## invokeBeanFactoryPostProcessors

### 介绍

本方法会实例化和调用所有 BeanFactoryPostProcessor（包括其子类 BeanDefinitionRegistryPostProcessor）

- BeanFactoryPostProcessor 接口是 Spring 初始化 BeanFactory 时对外暴露的扩展点，Spring IoC 容器允许 BeanFactoryPostProcessor 在容器实例化任何 bean 之前读取 bean 的定义，并可以修改它。
- BeanDefinitionRegistryPostProcessor 继承自BeanFactoryPostProcessor，比 BeanFactoryPostProcessor 具有更高的优先级，主要用来在常规的 BeanFactoryPostProcessor 检测开始之前注册其他 bean 定义。你可以通过 BeanDefinitionRegistryPostProcessor 来注册一些常规的 BeanFactoryPostProcessor，因为此时所有常规的 BeanFactoryPostProcessor 都还没开始被处理。 

### 扩展

#### BeanDefinitionRegistryPostProcessor

使用方法比较简单，新建一个类实现 BeanDefinitionRegistryPostProcessor 接口，并将该类注册到 Spring IoC 容器中。

```java
package com.joonwhee.open.demo.spring;
 
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
 
/**
 * @author joonwhee
 * @date 2019/2/18
 */
@Component
public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, Ordered {
 
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        System.out.println("MyBeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry");
        // 自己的逻辑处理
    }
 
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("MyBeanDefinitionRegistryPostProcessor#postProcessBeanFactory");
        // 自己的逻辑处理
    }
 
    @Override
    public int getOrder() {
        return 0;
    }
}
```

#### BeanFactoryPostProcessor

使用方法跟 BeanDefinitionRegistryPostProcessor 类似。

```java
package com.joonwhee.open.demo.spring;
 
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.stereotype.Component;
 
/**
 * @author joonwhee
 * @date 2019/2/18
 */
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("MyBeanFactoryPostProcessor#postProcessBeanFactory");
        // 自己的逻辑处理
    }
}
```

### 总结

- 在这个方法中完成`BeanDefinitionRegistryPostProcessor`和`BeanFactoryPostProcessor`的创建并且执行`BeanDefinitionRegistryPostProcessor`的       **postProcessBeanDefinitionRegistry()** 方法和`BeanFactoryPostProcessor`的 **postProcessBeanFactory()** 方法。
  -  **postProcessBeanDefinitionRegistry()** ：提供向容器中自定义注册bean的功能。
  - **postProcessBeanFactory()** ：可以修改beanFactory中bean的属性。
- BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor 。具有更高的优先级，执行顺序在 BeanFactoryPostProcessor 之前。

## registerBeanPostProcessors

### 介绍

registerBeanPostProcessors 方法主要用于处理 BeanPostProcessor 接口。BeanPostProcessor 是针对 bean 的扩展，主要用在 bean 实例化之后，执行初始化方法前后，允许开发者对 bean 实例进行修改。

在所有 bean 实例化时，执行初始化方法前会调用所有 BeanPostProcessor 的 postProcessBeforeInitialization 方法，在执行初始化方法后会调用所有 BeanPostProcessor 的 postProcessAfterInitialization 方法。

BeanPostProcessor

```java
public interface BeanPostProcessor {
 
	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
 
	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
```

- postProcessBeforeInitialization：触发时机在bean实例化(**Instantiation**)之后，所有初始化(**Initialization**)动作(包括 InitializingBean#afterPrpertiesSet() 和 定制化init-method())以前。
- postProcessAfterInitialization：触发时机在bean实例化(**Instantiation**)之后，所有初始化(**Initialization**)动作(包括 InitializingBean#afterPrpertiesSet() 和 定制化init-method())以后。同时还会在InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 和 FactoryBean(bean工厂)获得bean时候调用。

### 扩展

使用方法比较简单，新建一个类实现 BeanPostProcessor 接口，并将该类注册到 Spring IoC 容器中。

```java
package com.joonwhee.open.demo.spring;
 
import com.joonwhee.open.demo.service.UserService;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.core.PriorityOrdered;
 
/**
 * @author joonwhee
 * @date 2019/2/23
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {
 
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("MyBeanPostProcessor#postProcessBeforeInitialization");
        if (bean instanceof UserService) {
            System.out.println(beanName);
        }
        // 自己的逻辑
        return bean;
    }
 
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("MyBeanPostProcessor#postProcessAfterInitialization");
        // 自己的逻辑
        return bean;
    }
 
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 总结

- BeanPostProcessor注册的入口在AbstractApplicationContext容器启动的refresh()的AbstractApplicationContext#registerBeanPostProcessors。
- AbstractApplicationContext进而委派PostProcessorRegistrationDelegate#registerBeanPostProcessors实现注册。
- BeanPostProcessor类型实例会通过BeanFactory#getBean()提前初始化。

## beanPostProcessor

### 触发点

**创建一个Bean实例的执行流程**

protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args); 创建Bean

1. resolveBeanClass(mbd, beanName); 解析Bean class，

2. mbd.prepareMethodOverrides(); 准备和验证配置的方法注入，

3. Object bean = resolveBeforeInstantiation(beanName, mbd); **第一个BeanPostProcessor扩展点**，此处只执行InstantiationAwareBeanPostProcessor类型的BeanPostProcessor；

   1. bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);执行InstantiationAwareBeanPostProcessor的实例化的预处理回调方法postProcessBeforeInstantiation（自定义的实例化，如创建代理）；
   2. bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);执行InstantiationAwareBeanPostProcessor的实例化的后处理回调方法postProcessAfterInitialization（如依赖注入），如果3.1处返回的Bean不为null才执行；

4. 如果3处的扩展点返回的bean不为空，直接返回该bean，后续流程不需要执行；

5. Object beanInstance = doCreateBean(beanName, mbd, args); 执行spring的创建bean实例的流程；

6. createBeanInstance(beanName, mbd, args); 实例化Bean

   - instantiateUsingFactoryMethod 工厂方法实例化；
   - 构造器实例化
   - 如果之前已经解析过构造器
   - autowireConstructor：有参调用autowireConstructor实例化
   - instantiateBean：无参调用instantiateBean实例化；
   - 如果之前没有解析过构造器：
   - 通过SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors回调方法解析构造器，**第二个BeanPostProcessor扩展点**，返回第一个解析成功（返回值不为null）的构造器组，如AutowiredAnnotationBeanPostProcessor实现将自动扫描通过@Autowired/@Value注解的构造器从而可以完成构造器注入
   - autowireConstructor：如果（6.2.2.1返回的不为null，且是有参构造器，调用autowireConstructor实例化；
   - instantiateBean： 否则调用无参构造器实例化；

7. applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);**第三个BeanPostProcessor扩展点**，执行Bean定义的合并；

   - 执行MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition回调方法，进行bean定义的合并；

8. 及早暴露单例Bean工厂，从而允许setter注入方式的循环引用 

   ```java
   addSingletonFactory(beanName, new ObjectFactory() {
         public Object getObject() throws BeansException {
             return getEarlyBeanReference(beanName, mbd, bean);   
         }
   });
   ```

   - SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference；**第四个BeanPostProcessor扩展点**，当存在循环依赖时，通过该回调方法获取及早暴露的Bean实例；

9. populateBean(beanName, mbd, instanceWrapper);装配Bean依赖

   - InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation；**第五个BeanPostProcessor扩展点**，在实例化Bean之后，所有其他装配逻辑之前执行，如果false将阻止其他的InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation的执行和从（9.2到（9.5的执行，通常返回true；
   - autowireByName、autowireByType：根据名字和类型进行自动装配
   - InstantiationAwareBeanPostProcessor的postProcessPropertyValues：**第六个BeanPostProcessor扩展点**，完成其他定制的一些依赖注入，如AutowiredAnnotationBeanPostProcessor执行@Autowired注解注入，CommonAnnotationBeanPostProcessor执行@Resource等注解的注入，PersistenceAnnotationBeanPostProcessor执行@ PersistenceContext等JPA注解的注入，RequiredAnnotationBeanPostProcessor执行@ Required注解的检查等等，
   - checkDependencies：依赖检查，
   - applyPropertyValues：应用明确的setter属性注入，

10. exposedObject = initializeBean(beanName, exposedObject, mbd); 执行初始化Bean流程；

    - invokeAwareMethods（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）：调用一些Aware标识接口注入如BeanName、BeanFactory；
    - BeanPostProcessor的postProcessBeforeInitialization：**第七个扩展点**，在调用初始化之前完成一些定制的初始化任务，如BeanValidationPostProcessor完成JSR-303 @Valid注解Bean验证，InitDestroyAnnotationBeanPostProcessor完成@PostConstruct注解的初始化方法调用，ApplicationContextAwareProcessor完成一些Aware接口的注入（如EnvironmentAware、ResourceLoaderAware、ApplicationContextAware），其返回值将替代原始的Bean对象；
    - invokeInitMethods ： 调用初始化方法；
    - InitializingBean的afterPropertiesSet ：调用InitializingBean的afterPropertiesSet回调方法；
    - 通过xml指定的自定义init-method ：调用通过xml配置的自定义init-method
    - BeanPostProcessor的postProcessAfterInitialization ：**第八个扩展点**，AspectJAwareAdvisorAutoProxyCreator（完成xml风格的AOP配置(<aop:config>)的目标对象包装到AOP代理对象）、AnnotationAwareAspectJAutoProxyCreator（完成@Aspectj注解风格（<aop:aspectj-autoproxy> @Aspect）的AOP配置的目标对象包装到AOP代理对象），其返回值将替代原始的Bean对象；

11. 调用getSingle方法获取Bean实例；

    ```java
    if (earlySingletonExposure) {
    	Object earlySingletonReference = getSingleton(beanName, false);
    } ：如果是earlySingleExposure，调用getSingle方法获取Bean实例；
    earlySingleExposure =(mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName))
    ```

12. registerDisposableBeanIfNecessary(beanName, bean, mbd) **：** 注册Bean的销毁方法（只有非原型Bean可注册）；

    - 单例Bean的销毁流程
    - DestructionAwareBeanPostProcessor的postProcessBeforeDestruction ： **第九个扩展点**，如InitDestroyAnnotationBeanPostProcessor完成@PreDestroy注解的销毁方法注册和调用；
    - DisposableBean的destroy：注册/调用DisposableBean的destroy销毁方法；
    - 通过xml指定的自定义destroy-method ： 注册/调用通过XML指定的destroy-method销毁方法；
    - Scope的registerDestructionCallback：注册自定义的Scope的销毁回调方法，如RequestScope、SessionScope等；

13. 到此Bean实例化、依赖注入、初始化完毕可以返回创建好的bean了。

### 扩展介绍

![Spring_beanPostprocessor01](/Users/admin/Desktop/note/images/Spring/Spring_beanPostprocessor01.png)

从图中我们可以看出一共五个接口，共十个回调方法，即十个扩展点

#### InstantiationAwareBeanPostProcessor

实例化Bean后置处理器（继承BeanPostProcessor）

示例：

```java
// 配置类
@ComponentScan("com.dependency")
public class AppConfig {
}

//拦截器
public class BeanMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("目标方法前:" + method+"\n");
        Object object = methodProxy.invokeSuper(o, objects);
        System.out.println("目标方法后:" + method+"\n");
        return object;
    }
}

// 后置处理器
@Component
public class LogicInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessBeforeInstantiation\n");
        if(beanClass == X.class){
             //利用 其 生成动态代理
             Enhancer enhancer = new Enhancer();
             enhancer.setSuperclass(beanClass);
             enhancer.setCallback(new BeanMethodInterceptor());
             X bean = (X)enhancer.create();
             System.out.print("返回动态代理\n");
             return bean ;
         }
        return null;
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessAfterInstantiation\n");
        return true;
    }

    @Override
    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessProperties\n");
        return pvs;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessBeforeInitialization\n");
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessAfterInitialization\n");
        return bean;
    }
}

// 实体类
@Component
public class X {
    private String name ;

    public X (){
        System.out.println("X构造方法被调用**************");
        this.name = "chen";
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "X{" +
                "name='" + name + '\'' +
                '}';
    }
}

// 测试
public class TestDemo {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AppConfig.class);
        context.refresh();
        System.out.println(context.getBean(X.class).toString());
    }
}

```

运行结果如下:  由于postProcessBeforeInstantiation通过cglib生成代理,  所以直接执行BeanPostProcessor#postProcessAfterInitialization接口完成初始化。bean生命周期缩短

```java
// 返回结果
beanName:x执行..postProcessBeforeInstantiation                        //构造方法前执行
X构造方法被调用**************                                           //执行构造方法
返回动态代理
beanName:x执行..postProcessAfterInitialization                        //构造方法后执行
目标方法前:public java.lang.String com.dependency.service.X.toString() //执行方法前拦截器调用
目标方法后:public java.lang.String com.dependency.service.X.toString() //执行方法后拦截器调用
X{name='chen'}
```

修改LogicInstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation如下 :

```java
@Component
public class LogicInstantiationAwareBeanPostProcessor2 implements InstantiationAwareBeanPostProcessor {
    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessBeforeInstantiation\n");
        return null;
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessAfterInstantiation\n");
        return true;
    }

    @Override
    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessProperties\n");
        if(bean instanceof X){
             //修改bean中name 的属性值
             X value = (X) bean;
             String name = value.getName();
             System.out.print("修改之前 name 的value是："+value.getName()+"\n");
             value.setName("我修改啦");
             return pvs;
         }
        return pvs;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessBeforeInitialization\n");
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.print("beanName:"+beanName+"执行..postProcessAfterInitialization\n");
        return bean;
    }
}
```

运行结果如下:  由于postProcessBeforeInstantiation返回null 并 postProcessAfterInstantiation返回true 所以执行会postProcessProperties。此时bean生命周期正常process

```java
beanName:x执行..postProcessBeforeInstantiation
X构造方法被调用**************
beanName:x执行..postProcessAfterInstantiation
beanName:x执行..postProcessProperties
修改之前 name 的value是：chen
beanName:x执行..postProcessBeforeInitialization
beanName:x执行..postProcessAfterInitialization
X{name='我修改啦'}
```

总结

- bean实例化之前会检测是否存在该类型的接口，并触发前置postProcessBeforeInstantiation。注册多个实例时会依次执行回调，任何一个返回非null则直接执行BeanPostProcessor#postProcessAfterInitialization完成初始化。返回的bean直接返回容器，生命周期缩短。
- 后置postProcessAfterInstantiation会在实例化之后，依赖注入和初始化方法之前。注册多个接口只要其中一个返回false，即停止后续执行。 返回结果会影响后续执行流程，通过此定制化bean属性注入等操作。
- 优先回调postProcessProperties，spring-5.1之后新增回调接口 用以替代标注过时的postProcessPropertyValues方法

####  MergedBeanDefinitionPostProcessor

`MergedBeanDefinitionPostProcessor`会被应用到`bean`,在它被填充属性之前。

实现类：AutowiredAnnotationBeanPostProcessor

```java
public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
		implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {
	// ...		
	// 在每个bean实例化后，初始化前执行，获取并记录该bean属性注入的元数据，在随后的属性注入时使用
	// 该方法由接口MergedBeanDefinitionPostProcessor定义
	@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, 
		Class<?> beanType, String beanName) {
		// 获取指定bean的属性注入元数据
		InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);
		metadata.checkConfigMembers(beanDefinition);
	}
	// ...
}
```

这个类就是在实例化某个bean时，对bean中的属性或者方法进行扫描，扫描的是@Autowired和@Value注解，一旦发现方法或者属性上有这些注解，就把属性或者方法封装成AutowiredFieldElement或者AutowiredMethodElement对象，这个对象有一个Member，属性描述对象PropertyDescriptor，属性描述对象可以对属性进行反射读和写操作。最后把这些对象封装成InjectionMetadata对象，这些对象封装了类Class和集合，集合里面装了AutowiredFieldElement或者AutowiredMethodElement对象。这样AutowiredAnnotationBeanPostProcessor类的装配工作就完成了







